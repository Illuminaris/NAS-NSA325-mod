diff -Naur a/arch/arm/mach-kirkwood/common.h b/arch/arm/mach-kirkwood/common.h
--- a/arch/arm/mach-kirkwood/common.h	2014-03-30 20:40:15.000000000 -0700
+++ b/arch/arm/mach-kirkwood/common.h	2014-03-31 21:20:47.000000000 -0700
@@ -67,8 +67,6 @@
 /* board init functions for boards not fully converted to fdt */
 #ifdef CONFIG_MACH_MV88F6281GTW_GE_DT
 void mv88f6281gtw_ge_init(void);
-#else
-static inline void mv88f6281gtw_ge_init(void) {};
 #endif
 
 /* early init functions not converted to fdt yet */
diff -Naur a/arch/arm/mach-kirkwood/dockstar-setup.c b/arch/arm/mach-kirkwood/dockstar-setup.c
--- a/arch/arm/mach-kirkwood/dockstar-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/dockstar-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,115 @@
+/*
+ * arch/arm/mach-kirkwood/dockstar-setup.c
+ *
+ * Seagate FreeAgent DockStar Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition dockstar_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "data",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data dockstar_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct gpio_led dockstar_led_pins[] = {
+	{
+ 		.name			= "dockstar:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46,
+		.active_low		= 1,
+	},
+	{
+ 		.name			= "dockstar:orange:misc",
+		.default_trigger	= "none",
+		.gpio			= 47,
+		.active_low		= 1,
+	}
+};
+
+static struct gpio_led_platform_data dockstar_led_data = {
+	.leds		= dockstar_led_pins,
+	.num_leds	= ARRAY_SIZE(dockstar_led_pins),
+};
+
+static struct platform_device dockstar_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &dockstar_led_data,
+	}
+};
+
+static unsigned int dockstar_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	0
+};
+
+static void __init dockstar_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(dockstar_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(dockstar_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		pr_err("can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&dockstar_ge00_data);
+
+	platform_device_register(&dockstar_leds);
+}
+
+MACHINE_START(DOCKSTAR, "Seagate FreeAgent DockStar")
+	.atag_offset	= 0x100,
+	.init_machine	= dockstar_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/goflexhome-setup.c b/arch/arm/mach-kirkwood/goflexhome-setup.c
--- a/arch/arm/mach-kirkwood/goflexhome-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/goflexhome-setup.c	2014-04-15 01:55:32.000000000 -0700
@@ -0,0 +1,128 @@
+/*
+ * arch/arm/mach-kirkwood/goflexhome-setup.c
+ *
+ * Seagate GoFlex Home Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition goflexhome_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_2M + SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data goflexhome_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data goflexhome_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct gpio_led goflexhome_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 47,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:white:misc",
+		.default_trigger	= "none",
+		.gpio			= 40,
+		.active_low		= 0,
+	}
+};
+
+static struct gpio_led_platform_data goflexhome_led_data = {
+	.leds		= goflexhome_led_pins,
+	.num_leds	= ARRAY_SIZE(goflexhome_led_pins),
+};
+
+static struct platform_device goflexhome_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &goflexhome_led_data,
+	}
+};
+
+static unsigned int goflexhome_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP40_GPIO,	/* LED White */
+	0
+};
+
+static void __init goflexhome_init(void)
+{
+
+/* bodhi debug */
+#define ATA_DEBUG
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(goflexhome_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(goflexhome_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&goflexhome_ge00_data);
+	kirkwood_sata_init(&goflexhome_sata_data);
+
+	platform_device_register(&goflexhome_leds);
+}
+
+MACHINE_START(GOFLEXHOME, "Seagate GoFlex Home")
+	/* Maintainer: Peter Carmichael <peterjncarm@ovi.com> */
+	.atag_offset	= 0x00000100,
+	.init_machine	= goflexhome_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
+
diff -Naur a/arch/arm/mach-kirkwood/goflexnet-setup.c b/arch/arm/mach-kirkwood/goflexnet-setup.c
--- a/arch/arm/mach-kirkwood/goflexnet-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/goflexnet-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,177 @@
+/*
+ * arch/arm/mach-kirkwood/goflexnet-setup.c
+ *
+ * Seagate GoFlex Net Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition goflexnet_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data goflexnet_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data goflexnet_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_led goflexnet_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46, // 0x4000
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 47, // 0x8000
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:white:left0",
+		.default_trigger	= "none",
+		.gpio			= 42, // 0x0400
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left1",
+		.default_trigger	= "none",
+		.gpio			= 43, // 0x0800
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left2",
+		.default_trigger	= "none",
+		.gpio			= 44, // 0x1000
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left3",
+		.default_trigger	= "none",
+		.gpio			= 45, // 0x2000
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right0",
+		.default_trigger	= "none",
+		.gpio			= 38, // 0x0040
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right1",
+		.default_trigger	= "none",
+		.gpio			= 39, // 0x0080
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right2",
+		.default_trigger	= "none",
+		.gpio			= 40, // 0x0100
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right3",
+		.default_trigger	= "none",
+		.gpio			= 41, // 0x0200
+		.active_low		= 0,
+	}
+};
+
+static struct gpio_led_platform_data goflexnet_led_data = {
+	.leds		= goflexnet_led_pins,
+	.num_leds	= ARRAY_SIZE(goflexnet_led_pins),
+};
+
+static struct platform_device goflexnet_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &goflexnet_led_data,
+	}
+};
+
+static unsigned int goflexnet_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP45_GPIO,	/* LED Left Capacity 3 */
+	MPP44_GPIO,	/* LED Left Capacity 2 */
+	MPP43_GPIO,	/* LED Left Capacity 1 */
+	MPP42_GPIO,	/* LED Left Capacity 0 */
+	MPP41_GPIO,	/* LED Right Capacity 3 */
+	MPP40_GPIO,	/* LED Right Capacity 2 */
+	MPP39_GPIO,	/* LED Right Capacity 1 */
+	MPP38_GPIO,	/* LED Right Capacity 0 */
+	0
+};
+
+static void __init goflexnet_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(goflexnet_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(goflexnet_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&goflexnet_ge00_data);
+	kirkwood_sata_init(&goflexnet_sata_data);
+
+	platform_device_register(&goflexnet_leds);
+}
+
+MACHINE_START(GOFLEXNET, "Seagate GoFlex Net")
+	/* Maintainer: Peter Carmichael <peterjncarm@ovi.com> */
+	.atag_offset	= 0x00000100,
+	.init_machine	= goflexnet_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
+
diff -Naur a/arch/arm/mach-kirkwood/guruplug-setup.c b/arch/arm/mach-kirkwood/guruplug-setup.c
--- a/arch/arm/mach-kirkwood/guruplug-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/guruplug-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,135 @@
+/*
+ * arch/arm/mach-kirkwood/guruplug-setup.c
+ *
+ * Marvell GuruPlug Reference Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition guruplug_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data guruplug_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv643xx_eth_platform_data guruplug_ge01_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(1),
+};
+
+static struct mv_sata_platform_data guruplug_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct mvsdio_platform_data guruplug_mvsdio_data = {
+	/* unfortunately the CD signal has not been connected */
+	.gpio_card_detect = -1,
+	.gpio_write_protect = -1,
+};
+
+static struct gpio_led guruplug_led_pins[] = {
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 46,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 47,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:wmode",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:green:wmode",
+		.gpio			= 49,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data guruplug_led_data = {
+	.leds		= guruplug_led_pins,
+	.num_leds	= ARRAY_SIZE(guruplug_led_pins),
+};
+
+static struct platform_device guruplug_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &guruplug_led_data,
+	}
+};
+
+static unsigned int guruplug_mpp_config[] __initdata = {
+	MPP46_GPIO,	/* M_RLED */
+	MPP47_GPIO,	/* M_GLED */
+	MPP48_GPIO,	/* B_RLED */
+	MPP49_GPIO,	/* B_GLED */
+	0
+};
+
+static void __init guruplug_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(guruplug_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(guruplug_nand_parts), 40);
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&guruplug_ge00_data);
+	kirkwood_ge01_init(&guruplug_ge01_data);
+	kirkwood_sata_init(&guruplug_sata_data);
+	kirkwood_sdio_init(&guruplug_mvsdio_data);
+
+	platform_device_register(&guruplug_leds);
+}
+
+MACHINE_START(GURUPLUG, "Marvell GuruPlug Reference Board")
+	/* Maintainer: Siddarth Gore <gores@marvell.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= guruplug_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/iconnect-setup.c b/arch/arm/mach-kirkwood/iconnect-setup.c
--- a/arch/arm/mach-kirkwood/iconnect-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/iconnect-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,204 @@
+/*
+ * arch/arm/mach-kirkwood/iconnect-setup.c
+ *
+ * Iomega iConnect Wireless
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ethtool.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/i2c.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition iconnect_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_1M + SZ_2M
+	}, {
+		.name = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M,
+	}, {
+		.name = "data",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data iconnect_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(11),
+};
+
+static struct gpio_led iconnect_led_pins[] = {
+	{
+		.name			= "iconnect:led_level",
+		.default_trigger	= "default-on",
+		.gpio			= 41,
+	},
+	{
+		.name			= "iconnect:blue:power",
+		.default_trigger	= "default-on",
+		.gpio			= 42,
+	},
+	{
+		.name			= "iconnect:red:power",
+		.gpio			= 43,
+	},
+	{
+		.name			= "iconnect:blue:usb1",
+		.gpio			= 44,
+	},
+	{
+		.name			= "iconnect:blue:usb2",
+		.gpio			= 45,
+	},
+	{
+		.name			= "iconnect:blue:usb3",
+		.gpio			= 46,
+	},
+	{
+		.name			= "iconnect:blue:usb4",
+		.gpio			= 47,
+	},
+	{
+		.name			= "iconnect:blue:otb",
+		.gpio			= 48,
+	},
+};
+
+static struct gpio_led_platform_data iconnect_led_data = {
+	.leds		= iconnect_led_pins,
+	.num_leds	= ARRAY_SIZE(iconnect_led_pins),
+};
+
+static struct platform_device iconnect_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &iconnect_led_data,
+	}
+};
+
+#define ICONNECT_GPIO_KEY_RESET		12
+#define ICONNECT_GPIO_KEY_OTB		35
+
+#define ICONNECT_SW_RESET		0x00
+#define ICONNECT_SW_OTB			0x01
+
+static struct gpio_keys_button iconnect_buttons[] = {
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_RESET,
+		.gpio		= ICONNECT_GPIO_KEY_RESET,
+		.desc		= "Reset Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		}, 
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_OTB,
+		.gpio		= ICONNECT_GPIO_KEY_OTB,
+		.desc		= "OTB Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		},
+};
+
+static struct gpio_keys_platform_data iconnect_button_data = {
+	.buttons	= iconnect_buttons,
+	.nbuttons	= ARRAY_SIZE(iconnect_buttons),
+};
+
+static struct platform_device iconnect_button_device = {
+	.name	   = "gpio-keys",
+	.id	     = -1,
+	.num_resources	= 0,
+	.dev	    =	{
+					.platform_data  = &iconnect_button_data,
+					},
+};
+
+static unsigned int iconnect_mpp_config[] __initdata = {
+	MPP12_GPIO, /*Input for reset button*/
+	MPP35_GPIO, /*Input for OTB button*/
+	MPP41_GPIO,
+	MPP42_GPIO,
+	MPP43_GPIO,
+	MPP44_GPIO,
+	MPP45_GPIO,
+	MPP46_GPIO,
+	MPP47_GPIO,
+	MPP48_GPIO,
+	0
+};
+
+static struct i2c_board_info __initdata iconnect_i2c_rtc = {
+	I2C_BOARD_INFO("lm63", 0x4c),
+};
+
+static void __init iconnect_init(void)
+{
+	u32 dev, rev;
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(iconnect_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(iconnect_nand_parts), 40);
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&iconnect_ge00_data);
+	kirkwood_pcie_id(&dev, &rev);
+
+	kirkwood_uart0_init();
+
+	platform_device_register(&iconnect_leds);
+	platform_device_register(&iconnect_button_device);
+	
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, &iconnect_i2c_rtc, 1);
+
+}
+
+static int __init iconnect_pci_init(void)
+{
+	if (machine_is_iconnect())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(iconnect_pci_init);
+
+
+MACHINE_START(ICONNECT, "Iomega iConnect Wireless")
+	.atag_offset	= 0x00000100,
+	.init_machine	= iconnect_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/Kconfig b/arch/arm/mach-kirkwood/Kconfig
--- a/arch/arm/mach-kirkwood/Kconfig	2014-03-30 20:40:15.000000000 -0700
+++ b/arch/arm/mach-kirkwood/Kconfig	2014-04-07 15:51:56.000000000 -0700
@@ -5,29 +5,55 @@
 config KIRKWOOD_LEGACY
 	bool
 
-config MACH_D2NET_V2
-	bool "LaCie d2 Network v2 NAS Board"
-	select KIRKWOOD_LEGACY
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  LaCie d2 Network v2 NAS.
-
 config MACH_NET2BIG_V2
 	bool "LaCie 2Big Network v2 NAS Board"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  LaCie 2Big Network v2 NAS.
 
 config MACH_NET5BIG_V2
 	bool "LaCie 5Big Network v2 NAS Board"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  LaCie 5Big Network v2 NAS.
 
+config MACH_GOFLEXNET
+        bool "Seagate GoFlex Net"
+        help
+          Say 'Y' here if you want your kernel to support the
+          Seagate GoFlex Net.
+
+config MACH_GOFLEXHOME
+        bool "Seagate GoFlex Home"
+        help
+          Say 'Y' here if you want your kernel to support the
+          Seagate GoFlex Home.
+
+config MACH_ICONNECT
+	bool "Iomega iConnect Wireless"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Iomega iConnect Wireless.
+
+config MACH_POGOPLUGV4
+	bool "Pogoplug Series 4"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Pogoplug Series 4.
+
+config MACH_POGO_E02
+	bool "CE Pogoplug E02"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  CloudEngines Pogoplug e02.
+
+config MACH_NAS6210
+	bool "RaidSonic ICY BOX IB-NAS6210"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  RaidSonic ICY BOX IB-NAS6210 device.
+
 config MACH_OPENRD
-	select KIRKWOOD_LEGACY
         bool
 
 config MACH_OPENRD_BASE
@@ -53,28 +79,24 @@
 
 config MACH_RD88F6192_NAS
 	bool "Marvell RD-88F6192-NAS Reference Board"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell RD-88F6192-NAS Reference Board.
 
 config MACH_RD88F6281
 	bool "Marvell RD-88F6281 Reference Board"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell RD-88F6281 Reference Board.
 
 config MACH_T5325
 	bool "HP t5325 Thin Client"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  HP t5325 Thin Client.
 
 config MACH_TS219
 	bool "QNAP TS-110, TS-119, TS-119P+, TS-210, TS-219, TS-219P and TS-219P+ Turbo NAS"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  QNAP TS-110, TS-119, TS-119P+, TS-210, TS-219, TS-219P and
@@ -82,12 +104,75 @@
 
 config MACH_TS41X
 	bool "QNAP TS-410, TS-410U, TS-419P, TS-419P+ and TS-419U Turbo NAS"
-	select KIRKWOOD_LEGACY
 	help
 	  Say 'Y' here if you want your kernel to support the
 	  QNAP TS-410, TS-410U, TS-419P, TS-419P+ and TS-419U Turbo
 	  NAS devices.
 
+config MACH_D2NET_V2
+	bool "LaCie d2 Network v2 NAS Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  LaCie d2 Network v2 NAS.
+
+config MACH_DOCKSTAR
+	bool "Seagate FreeAgent DockStar"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Seagate FreeAgent DockStar.
+
+config MACH_ESATA_SHEEVAPLUG
+	bool "Marvell eSATA SheevaPlug Reference Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell eSATA SheevaPlug Reference Board.
+
+config MACH_GURUPLUG
+	bool "Marvell GuruPlug Reference Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell GuruPlug Reference Board.
+
+config MACH_SHEEVAPLUG
+	bool "Marvell SheevaPlug Reference Board"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Marvell SheevaPlug Reference Board.
+
+config MACH_NSA320
+   bool "ZyXEL NSA320 2-Bay Power Media Server"
+   help
+     Say 'Y' here if you want your kernel to support the
+     ZyXel NSA320.
+
+config MACH_TOPKICK
+ 	bool "USI Topkick"
+ 	help
+ 		Say 'Y' here if you want your kernel to support the
+ 		USI Topkick.
+
+config MACH_NSA310
+       bool "ZyXEL NSA310 1-Bay Power Media Server"
+       help
+         Say 'Y' here if you want your kernel to support the
+         ZyXEL NSA310.
+
+       help
+         Say 'Y' here if you want your kernel to support the
+         ZyXEL NSA320.
+
+config MACH_NSA325
+   bool "ZyXEL NSA325 2-Bay Power Media Server"
+   help
+     Say 'Y' here if you want your kernel to support the
+     ZyXel NSA325.
+
+config MACH_NETGEAR_MS2110
+               bool "Netgear MS2110 aka Stora"
+               help
+                 Say 'Y' here if you want your kernel to support the
+                 Netgear Stora
+
 comment "Device tree entries"
 
 config ARCH_KIRKWOOD_DT
@@ -113,6 +198,7 @@
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell 88F6281 GTW GE Board (Flattened Device Tree).
 
+
 endmenu
 
 endif
diff -Naur a/arch/arm/mach-kirkwood/Makefile b/arch/arm/mach-kirkwood/Makefile
--- a/arch/arm/mach-kirkwood/Makefile	2014-03-30 20:40:15.000000000 -0700
+++ b/arch/arm/mach-kirkwood/Makefile	2014-04-07 15:53:17.000000000 -0700
@@ -1,6 +1,4 @@
-obj-y				+= common.o pcie.o
-obj-$(CONFIG_KIRKWOOD_LEGACY)	+= irq.o mpp.o
-obj-$(CONFIG_PM)		+= pm.o
+obj-y				+= common.o irq.o pcie.o mpp.o
 
 obj-$(CONFIG_MACH_D2NET_V2)		+= d2net_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_NET2BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
@@ -12,5 +10,20 @@
 obj-$(CONFIG_MACH_TS219)		+= ts219-setup.o tsx1x-common.o
 obj-$(CONFIG_MACH_TS41X)		+= ts41x-setup.o tsx1x-common.o
 
-obj-$(CONFIG_ARCH_KIRKWOOD_DT)		+= board-dt.o
-obj-$(CONFIG_MACH_MV88F6281GTW_GE_DT)	+= board-mv88f6281gtw_ge.o
+obj-$(CONFIG_MACH_DOCKSTAR)		+= dockstar-setup.o
+obj-$(CONFIG_MACH_ESATA_SHEEVAPLUG)	+= sheevaplug-setup.o
+obj-$(CONFIG_MACH_GURUPLUG)		+= guruplug-setup.o
+obj-$(CONFIG_MACH_INETSPACE_V2)		+= netspace_v2-setup.o lacie_v2-common.o
+obj-$(CONFIG_MACH_MV88F6281GTW_GE)	+= mv88f6281gtw_ge-setup.o
+obj-$(CONFIG_MACH_SHEEVAPLUG)		+= sheevaplug-setup.o
+obj-$(CONFIG_MACH_GOFLEXNET)		+= goflexnet-setup.o
+obj-$(CONFIG_MACH_GOFLEXHOME)		+= goflexhome-setup.o
+obj-$(CONFIG_MACH_ICONNECT)		+= iconnect-setup.o
+obj-$(CONFIG_MACH_POGOPLUGV4)		+= pogoplugv4-setup.o
+obj-$(CONFIG_MACH_POGO_E02)		+= pogo_e02-setup.o
+obj-$(CONFIG_MACH_NSA320)               += nsa320-setup.o
+obj-$(CONFIG_MACH_TOPKICK)		+= topkick-setup.o
+obj-$(CONFIG_MACH_NSA310)               += nsa310-setup.o
+obj-$(CONFIG_MACH_NSA325)               += nsa325-setup.o
+obj-$(CONFIG_MACH_NETGEAR_MS2110)       += netgear_ms2110-setup.o
+
diff -Naur a/arch/arm/mach-kirkwood/mpp.h b/arch/arm/mach-kirkwood/mpp.h
--- a/arch/arm/mach-kirkwood/mpp.h	2014-03-30 20:40:15.000000000 -0700
+++ b/arch/arm/mach-kirkwood/mpp.h	2014-03-31 21:20:47.000000000 -0700
@@ -102,7 +102,7 @@
 #define MPP11_SATA0_ACTn	MPP( 11, 0x5, 0, 0, 0,   1,   1,   1,   1 )
 
 #define MPP12_GPO		MPP( 12, 0x0, 0, 1, 1,   1,   1,   1,   1 )
-#define MPP12_GPIO		MPP( 12, 0x0, 1, 1, 0,   0,   0,   1,   0 )
+#define MPP12_GPIO		MPP( 12, 0x0, 1, 1, 1,   1,   1,   1,   1 )
 #define MPP12_SD_CLK		MPP( 12, 0x1, 0, 0, 1,   1,   1,   1,   1 )
 #define MPP12_AU_SPDIF0		MPP( 12, 0xa, 0, 0, 0,   0,   0,   0,   1 )
 #define MPP12_SPI_MOSI		MPP( 12, 0xb, 0, 0, 0,   0,   0,   0,   1 )
diff -Naur a/arch/arm/mach-kirkwood/nas6210-setup.c b/arch/arm/mach-kirkwood/nas6210-setup.c
--- a/arch/arm/mach-kirkwood/nas6210-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/nas6210-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,186 @@
+/*
+ * arch/arm/mach-kirkwood/nas6210-setup.c
+ *
+ * Raidsonic ICYBOX NAS6210 Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+#define NAS6210_GPIO_POWER_OFF	24
+
+static struct mtd_partition nas6210_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 6*SZ_1M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data nas6210_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(8),
+};
+
+static struct mv_sata_platform_data nas6210_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_led nas6210_led_pins[] = {
+	{
+		.name			= "status:green:power",
+		.default_trigger	= "default-on",
+		.gpio			= 25,
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:red:power",
+		.default_trigger	= "none",
+		.gpio			= 22,
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:red:usb_copy",
+		.default_trigger	= "none",
+		.gpio			= 27,
+		.active_low		= 0,
+	},
+};
+
+static struct gpio_led_platform_data nas6210_led_data = {
+	.leds		= nas6210_led_pins,
+	.num_leds	= ARRAY_SIZE(nas6210_led_pins),
+};
+
+static struct platform_device nas6210_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nas6210_led_data,
+	}
+};
+
+static struct gpio_keys_button nas6210_buttons[] = {
+	{
+		.code		= KEY_COPY,
+		.gpio		= 29,
+		.desc		= "USB Copy",
+		.active_low	= 1,
+	},
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 28,
+		.desc		= "Reset",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data nas6210_button_data = {
+	.buttons	= nas6210_buttons,
+	.nbuttons	= ARRAY_SIZE(nas6210_buttons),
+};
+
+static struct platform_device nas6210_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nas6210_button_data,
+	}
+};
+
+static unsigned int nas6210_mpp_config[] __initdata = {
+	MPP0_NF_IO2,
+	MPP1_NF_IO3,
+	MPP2_NF_IO4,
+	MPP3_NF_IO5,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP18_NF_IO0,
+	MPP19_NF_IO1,
+ 	MPP22_GPIO,	/* Power LED red */
+	MPP24_GPIO,	/* Power off device */
+	MPP25_GPIO,	/* Power LED green */
+	MPP27_GPIO,	/* USB transfer LED */
+	MPP28_GPIO,	/* Reset button */
+	MPP29_GPIO,	/* USB Copy button */
+	0
+};
+
+static void nas6210_power_off(void)
+{
+	gpio_set_value(NAS6210_GPIO_POWER_OFF, 1);
+}
+
+static void __init nas6210_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(nas6210_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(nas6210_nand_parts), 40);
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&nas6210_ge00_data);
+	kirkwood_sata_init(&nas6210_sata_data);
+	kirkwood_uart0_init();
+	platform_device_register(&nas6210_leds);
+	platform_device_register(&nas6210_button_device);
+	if (gpio_request(NAS6210_GPIO_POWER_OFF, "power-off") == 0 &&
+	    gpio_direction_output(NAS6210_GPIO_POWER_OFF, 0) == 0)
+		pm_power_off = nas6210_power_off;
+	else
+		pr_err("nas6210: failed to configure power-off GPIO\n");
+}
+
+static int __init nas6210_pci_init(void)
+{
+	if (machine_is_nas6210()) {
+		u32 dev, rev;
+ 
+		kirkwood_pcie_id(&dev, &rev);
+		if (dev == MV88F6282_DEV_ID)
+			kirkwood_pcie_init(KW_PCIE1 | KW_PCIE0);
+		else
+			kirkwood_pcie_init(KW_PCIE0);
+	}
+
+	return 0;
+}
+subsys_initcall(nas6210_pci_init);
+
+MACHINE_START(NAS6210, "RaidSonic ICY BOX IB-NAS6210")
+	/* Maintainer: <gmbnomis at gmail dot com> */
+	.atag_offset	= 0x00000100,
+	.init_machine	= nas6210_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/netgear_ms2110-setup.c b/arch/arm/mach-kirkwood/netgear_ms2110-setup.c
--- a/arch/arm/mach-kirkwood/netgear_ms2110-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/netgear_ms2110-setup.c	2014-04-07 16:23:59.000000000 -0700
@@ -0,0 +1,293 @@
+/*
+ * arch/arm/mach-kirkwood/netgear_ms2110-setup.c 
+ *
+ * Netgear MS2110 (Stora) Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/platform_data/at24.h>
+#include <linux/input.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/orion-gpio.h>
+#include "common.h"
+#include "mpp.h"
+
+#define MACH_TYPE_NETGEAR_MS2110        2743
+
+#ifdef CONFIG_MACH_NETGEAR_MS2110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETGEAR_MS2110
+# endif
+# define machine_is_netgear_ms2110()	(machine_arch_type == MACH_TYPE_NETGEAR_MS2110)
+#else
+# define machine_is_netgear_ms2110()	(0)
+#endif
+
+static struct mtd_partition netgear_ms2110_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M + SZ_2M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data netgear_ms2110_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(8),
+};
+
+static struct mv_sata_platform_data netgear_ms2110_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct i2c_board_info  __initdata netgear_ms2110_i2c_info[] = {
+   { I2C_BOARD_INFO("pcf8563", 0x51 ) },
+   { I2C_BOARD_INFO("lm75", 0x48 ) }
+}; 
+
+#define NETGEAR_MS2110_POWER_BUTTON 36
+#define NETGEAR_MS2110_RESET_BUTTON 38
+
+static struct gpio_keys_button netgear_ms2110_buttons[] = {
+        [0] = {
+                .code           = KEY_POWER,
+                .gpio           = NETGEAR_MS2110_POWER_BUTTON,
+                .desc           = "Power push button",
+                .active_low     = 1,
+        },
+        [1] = {
+                .code           = KEY_POWER2,
+                .gpio           = NETGEAR_MS2110_RESET_BUTTON,
+                .desc           = "Reset push button",
+                .active_low     = 1,
+        },
+};
+
+static struct gpio_keys_platform_data netgear_ms2110_button_data = {
+        .buttons        = netgear_ms2110_buttons,
+        .nbuttons       = ARRAY_SIZE(netgear_ms2110_buttons),
+};
+
+static struct platform_device netgear_ms2110_gpio_buttons = {
+        .name           = "gpio-keys",
+        .id             = -1,
+        .dev            = {
+                .platform_data  = &netgear_ms2110_button_data,
+        },
+};
+
+static unsigned int netgear_ms2110_mpp_config[] __initdata = {
+	MPP0_NF_IO2,  /* nand controller */
+	MPP1_NF_IO3,  /* nand controller */
+	MPP2_NF_IO4,  /* nand controller */
+	MPP3_NF_IO5,  /* nand controller */
+	MPP4_NF_IO6,  /* nand controller */
+	MPP5_NF_IO7,  /* nand controller */
+	MPP6_SYSRST_OUTn, /* system reset out */
+	MPP7_SPI_SCn, 
+	MPP8_TW0_SDA,  /* TWSI data */
+	MPP9_TW0_SCK,  /* TWSI clock */
+	MPP10_UART0_TXD, /* ttyS0 tx */
+	MPP11_UART0_RXD, /* ttys0 rx */
+	MPP12_SD_CLK,
+	MPP13_SD_CMD,
+	MPP14_SD_D0,
+	MPP15_SD_D1,
+	MPP16_SD_D2,
+	MPP17_SD_D3,
+	MPP18_NF_IO0,  /* nand controller */
+	MPP19_NF_IO1,  /* nand controller */
+	MPP20_SATA1_ACTn, /* green led for drive 2 */
+	MPP21_SATA0_ACTn, /* green led for drive 1 */
+	MPP22_GPIO,   /* red led for drive 2 */
+	MPP23_GPIO,   /* red led for drive 1 */
+	MPP24_GE1_RXD0,
+	MPP25_GE1_RXD1,
+	MPP26_GE1_RXD2,
+	MPP27_GE1_RXD3,
+	MPP28_GPIO,
+	MPP29_GPIO,
+	MPP30_GPIO, 
+	MPP31_GPIO,  /* blue led for power indicator 1 */
+	MPP32_GPIO,  /* blue led for power indicator 2 */
+	MPP33_GE1_TXCTL,
+	MPP34_SATA1_ACTn, /* positively retarded, unused, and nonstandard */
+	MPP35_GPIO,
+	MPP36_GPIO,  /* power button input */
+	MPP37_GPIO,  /* reset button input */
+	MPP38_GPIO,
+	MPP39_GPIO,
+	MPP40_GPIO,  /* low output powers off board */
+	MPP41_GPIO,  /* input from fan tachometer -- kind of pointless */
+	MPP42_GPIO,
+	MPP43_GPIO,  /* Green 1000M phy led enable */
+	MPP44_GPIO,  /* Yellow 10M/100M phy led enable */
+	MPP45_TDM_PCLK, /* tp11 on the board */
+	MPP46_TDM_FS,   /* tp12 on the board */
+	MPP47_TDM_DRX,  /* tp13 on the board */
+	MPP48_TDM_DTX,  /* tp14 on the board */
+	MPP49_GPIO,     /* tp15 on the board */
+	0
+};
+
+#define NETGEAR_MS2110_GPIO_POWER_OFF 40
+
+static void netgear_ms2110_power_off(void)
+{
+        gpio_set_value(NETGEAR_MS2110_GPIO_POWER_OFF, 1);
+}
+
+#define NETGEAR_MS2110_GPIO_BLUE1_LED     31
+#define NETGEAR_MS2110_GPIO_BLUE2_LED     32
+#define NETGEAR_MS2110_GPIO_RED1_LED     23
+#define NETGEAR_MS2110_GPIO_RED2_LED     22
+
+static int netgear_ms2110_gpio_blink_set(unsigned gpio, int state, unsigned long *delay_on, unsigned long *delay_off) {
+	if (*delay_on == 0 && *delay_off == 1) { 
+		/* this special case turns on hardware blinking */
+		orion_gpio_set_blink(gpio,1);
+		return 0;
+	}
+	orion_gpio_set_blink(gpio,0); /* turn off hardware blinking */
+	if (*delay_off == 0 && *delay_off == 0)
+		return 0; /* we're done */
+	else
+		return 1; /* fall back to the software blinking */
+}
+
+static struct gpio_led netgear_ms2110_gpio_led_pins[] = {
+        {
+                .name   = "blue1",
+                .gpio   = NETGEAR_MS2110_GPIO_BLUE1_LED,
+                .active_low     = 1,
+		.default_trigger = "heartbeat",
+		.default_state = LEDS_GPIO_DEFSTATE_KEEP,
+        },
+        {
+                .name   = "blue2",
+                .gpio   = NETGEAR_MS2110_GPIO_BLUE2_LED,
+                .active_low     = 1,
+		.default_trigger = "default-on",
+		.default_state = LEDS_GPIO_DEFSTATE_KEEP,
+        },
+        {
+                .name   = "red1",
+                .gpio   = NETGEAR_MS2110_GPIO_RED1_LED,
+                .active_low     = 1,
+		.default_trigger = "none",
+		.default_state = LEDS_GPIO_DEFSTATE_KEEP,
+        },
+        {
+                .name   = "red2",
+                .gpio   = NETGEAR_MS2110_GPIO_RED2_LED,
+                .active_low     = 1,
+		.default_trigger = "none",
+		.default_state = LEDS_GPIO_DEFSTATE_KEEP,
+        },
+};
+
+static struct gpio_led_platform_data netgear_ms2110_gpio_leds_data = {
+        .num_leds       = ARRAY_SIZE(netgear_ms2110_gpio_led_pins),
+        .leds           = netgear_ms2110_gpio_led_pins,
+	.gpio_blink_set = netgear_ms2110_gpio_blink_set,
+};
+
+
+static struct platform_device netgear_ms2110_gpio_leds = {
+        .name           = "leds-gpio",
+        .id             = -1,
+        .dev            = {
+                .platform_data  = &netgear_ms2110_gpio_leds_data,
+        },
+};
+
+static void __init netgear_ms2110_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(netgear_ms2110_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(netgear_ms2110_nand_parts), 25);
+
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&netgear_ms2110_ge00_data);
+	kirkwood_sata_init(&netgear_ms2110_sata_data);
+
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, netgear_ms2110_i2c_info,
+                                ARRAY_SIZE(netgear_ms2110_i2c_info));
+        
+	platform_device_register(&netgear_ms2110_gpio_buttons);
+
+	if (gpio_request(NETGEAR_MS2110_GPIO_POWER_OFF, "power-off") == 0 &&
+            gpio_direction_output(NETGEAR_MS2110_GPIO_POWER_OFF, 0) == 0)
+                pm_power_off = netgear_ms2110_power_off;
+        else
+                pr_err("netgear_ms2110: failed to configure power-off GPIO\n");
+
+	if (gpio_request(NETGEAR_MS2110_GPIO_BLUE1_LED,"power-light1") == 0 &&
+	    gpio_direction_output(NETGEAR_MS2110_GPIO_BLUE1_LED, 0) == 0) {
+	        gpio_set_value(NETGEAR_MS2110_GPIO_BLUE1_LED,0);
+	        orion_gpio_set_blink(NETGEAR_MS2110_GPIO_BLUE1_LED,0);
+            } else
+	        pr_err("netgear_ms2110: failed to configure blue LED1\n");
+	if (gpio_request(NETGEAR_MS2110_GPIO_BLUE2_LED,"power-light2") == 0 &&
+	    gpio_direction_output(NETGEAR_MS2110_GPIO_BLUE2_LED, 0) == 0) {
+	        gpio_set_value(NETGEAR_MS2110_GPIO_BLUE2_LED,0);
+	        orion_gpio_set_blink(NETGEAR_MS2110_GPIO_BLUE2_LED,0);
+            } else
+	        pr_err("netgear_ms2110: failed to configure blue LED2\n");
+	gpio_free(NETGEAR_MS2110_GPIO_BLUE1_LED);
+	gpio_free(NETGEAR_MS2110_GPIO_BLUE2_LED);
+        platform_device_register(&netgear_ms2110_gpio_leds);
+
+}
+
+static int __init netgear_ms2110_pci_init(void)
+{
+	if (machine_is_netgear_ms2110())
+	    kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+ }
+subsys_initcall(netgear_ms2110_pci_init);
+
+
+MACHINE_START(NETGEAR_MS2110, "Netgear MS2110")
+        .atag_offset	= 0x100,
+	.init_machine	= netgear_ms2110_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/nsa310-setup.c b/arch/arm/mach-kirkwood/nsa310-setup.c
--- a/arch/arm/mach-kirkwood/nsa310-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/nsa310-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,358 @@
+/*
+ * arch/arm/mach-kirkwood/nsa310-setup.c
+ *
+ * Zyxel NSA-310 Setup, by AA666 and Peeter123
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/mtd/partitions.h>
+#include <mtd/mtd-abi.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/mv643xx_i2c.h>
+#include <linux/ethtool.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <plat/orion-gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+static void nsa310_timerfunc(unsigned long data);
+static DEFINE_TIMER(timer, nsa310_timerfunc, 0, 0);
+
+static struct mtd_partition nsa310_nand_parts[] = {
+  {
+    .name = "uboot",
+    .offset = 0,
+    .size = 0x100000,
+    .mask_flags = MTD_WRITEABLE
+  }, {
+    .name = "uboot_env",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x80000
+  }, {
+    .name = "key_store",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x80000
+  }, {
+    .name = "info",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x80000
+  }, {
+    .name = "etc",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0xA00000
+  }, {
+    .name = "kernel_1",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0xA00000
+  }, {
+    .name = "rootfs1",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x2FC0000
+  }, {
+    .name = "kernel_2",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0xA00000
+  }, {
+    .name = "rootfs2",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x2FC0000
+  },
+};
+
+static struct i2c_board_info __initdata nsa310_i2c_rtc = {
+        I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa310_ge00_data = {
+  .phy_addr  = MV643XX_ETH_PHY_ADDR(0),
+  .speed    = SPEED_1000,
+  .duplex    = DUPLEX_FULL,
+};
+
+static struct mv_sata_platform_data nsa310_sata_data = {
+  .n_ports  = 2,
+};
+
+static unsigned int nsa310_mpp_config[] __initdata = {
+  MPP36_GPIO, // Reset button
+  MPP37_GPIO, // Copy button
+  MPP46_GPIO, // Power button
+
+  MPP48_GPIO, // Power Off
+  MPP21_GPIO, // USB Power Off
+
+  MPP28_GPIO, // Sys LED Green
+  MPP29_GPIO, // Sys LED Yellow
+  MPP41_GPIO, // SATA1 LED Green
+  MPP42_GPIO, // SATA1 LED Red
+  MPP12_GPO, // SATA2 LED Green
+  MPP13_GPIO, // SATA2 LED Red
+  MPP39_GPIO, // Copy LED Green
+  MPP40_GPIO, // Copy LED Red
+  MPP15_GPIO, // USB LED Green
+
+  MPP14_GPIO, // MCU Data
+  MPP16_GPIO, // MCU Clk
+  MPP17_GPIO, // MCU Act
+
+  MPP38_GPIO, // VID B0
+  MPP45_GPIO, // VID B1
+
+  MPP44_GPIO, // Buzzer
+  MPP43_GPIO, // HTP
+
+  MPP47_GPIO, // Power Resume Data
+  MPP49_GPIO, // Power Resume Clock
+
+  0
+};
+
+static struct gpio_led nsa310_gpio_led[] = {
+        {
+            .name    = "nsa310:green:System",
+            .default_trigger  = "timer",
+            .gpio    = 28,
+            .active_low    = 0,
+
+        },
+  {
+            .name    = "nsa310:red:System",
+            .default_trigger  = "none",
+            .gpio    = 29,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:green:SATA1",
+            .default_trigger  = "none",
+            .gpio    = 41,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:red:SATA1",
+            .default_trigger  = "sata-disk",
+            .gpio    = 42,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:green:SATA2",
+            .default_trigger  = "none",
+            .gpio    = 12,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:red:SATA2",
+            .default_trigger  = "none",
+            .gpio    = 13,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:green:USB",
+            .default_trigger  = "none",
+            .gpio    = 15,
+            .active_low    = 0,
+        },
+        {
+            .name    = "nsa310:green:Copy",
+            .default_trigger  = "none",
+            .gpio    = 39,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:red:Copy",
+            .default_trigger  = "none",
+            .gpio    = 40,
+            .active_low    = 0,
+        },
+};
+
+
+static int nsa310_gpio_blink_set(unsigned gpio, int state,
+  unsigned long *delay_on, unsigned long *delay_off)
+{
+
+// Use hardware acceleration
+//    if (delay_on && delay_off && !*delay_on && !*delay_off)
+//  *delay_on = *delay_off = 100;
+
+  switch(state) {
+      case GPIO_LED_NO_BLINK_LOW:
+      case GPIO_LED_NO_BLINK_HIGH:
+    orion_gpio_set_blink(gpio, 0);
+    gpio_set_value(gpio, state);
+      break;
+      case GPIO_LED_BLINK:
+    orion_gpio_set_blink(gpio, 1);
+      break;
+  }
+  return 0;
+}
+
+
+static struct gpio_led_platform_data nsa310_led_data = {
+        .leds           = nsa310_gpio_led,
+        .num_leds       = ARRAY_SIZE(nsa310_gpio_led),
+  .gpio_blink_set  = nsa310_gpio_blink_set,
+};
+
+static struct platform_device nsa310_leds = {
+        .name   = "leds-gpio",
+        .id     = -1,
+        .dev    = { .platform_data  = &nsa310_led_data, }
+};
+
+static struct gpio_keys_button nsa310_gpio_keys_button[] = {
+        {
+            .code             = KEY_POWER,
+            .type    = EV_KEY,
+            .gpio             = 46,
+            .desc             = "Power Button",
+            .active_low       = 0,
+            .debounce_interval   = 1000,
+        },
+        {
+            .code             = KEY_COPY,
+            .type    = EV_KEY,
+            .gpio             = 37,
+            .desc             = "USB Copy",
+            .active_low       = 1,
+            .debounce_interval   = 1000,
+        },
+        {
+            .code             = KEY_OPTION,
+            .type    = EV_KEY,
+            .gpio             = 36,
+            .desc             = "Reset",
+            .active_low       = 1,
+            .debounce_interval   = 1000,
+        },
+};
+
+static struct gpio_keys_platform_data nsa310_keys_data = {
+        .buttons        = nsa310_gpio_keys_button,
+        .nbuttons       = ARRAY_SIZE(nsa310_gpio_keys_button),
+};
+
+
+static struct platform_device nsa310_buttons = {
+        .name           = "gpio-keys",
+        .id             = -1,
+        .dev            = { .platform_data  = &nsa310_keys_data, }
+};
+
+static void nsa310_power_off(void)
+{
+//
+//don't work with sysfs
+      printk(KERN_INFO "Activating power off GPIO pin...\n");
+  gpio_set_value(48, 1);
+
+// If machine goes to restart, uncomment next lines for infinite loop
+/*      printk(KERN_INFO "System halted, please turn off power manually\n");
+  gpio_set_value(28, 0);
+  do {
+      mdelay(1000);
+  } while(1);
+*/
+}
+
+static void nsa310_timerfunc(unsigned long data)
+{
+// Activate USB Power
+  if (gpio_request(21, "USB Power") != 0 || gpio_direction_output(21, 1) != 0)
+      printk(KERN_ERR "failed to setup USB power GPIO\n");
+  else
+          printk(KERN_INFO "USB power enabled\n");
+  gpio_free(21);
+}
+
+static void __init nsa310_init(void)
+{
+  u32 dev, rev;
+
+  kirkwood_init();
+
+  kirkwood_mpp_conf(nsa310_mpp_config);
+  kirkwood_nand_init(ARRAY_AND_SIZE(nsa310_nand_parts), 40);
+  kirkwood_ge00_init(&nsa310_ge00_data);
+  kirkwood_pcie_id(&dev, &rev);
+
+  kirkwood_sata_init(&nsa310_sata_data);
+  kirkwood_uart0_init();
+  kirkwood_i2c_init();
+        i2c_register_board_info(0, &nsa310_i2c_rtc, 1);
+
+  platform_device_register(&nsa310_leds);
+  platform_device_register(&nsa310_buttons);
+  
+  kirkwood_ehci_init();
+//  USB Power delay for 20 sec  
+  timer.function = nsa310_timerfunc;
+        timer.data = 0;
+  timer.expires = jiffies + msecs_to_jiffies(20000);
+  add_timer(&timer);
+
+
+/*  Power resume control */
+      gpio_request(49, "Power-clk");
+      gpio_direction_output(49, 1);
+      gpio_request(47, "Power-data");
+// Clear power resume
+//      gpio_direction_output(47, 0);
+// Set power resume
+      gpio_direction_output(47, 1);
+      udelay(1000);
+//      gpio_direction_output(49, 0);
+      gpio_set_value(49, 0);
+// release GPIO?
+//test
+      gpio_free(47);
+      gpio_free(49);
+          printk(KERN_INFO "Power resume enabled\n");
+
+
+// Activate Power-off GPIO
+  if (gpio_request(48, "Power-off") == 0 && gpio_direction_output(48, 0) == 0) {
+//          gpio_free(48);
+            pm_power_off = nsa310_power_off;
+          printk(KERN_INFO "Power-off GPIO enabled\n");
+      } else
+    printk(KERN_ERR "failed to configure Power-off GPIO\n");
+
+};
+
+static int __init nsa310_pci_init(void)
+{
+  if (machine_is_nsa310())
+    kirkwood_pcie_init(KW_PCIE0);
+  return 0;
+}
+
+subsys_initcall(nsa310_pci_init);
+
+MACHINE_START(NSA310, "Zyxel NSA-310")
+	.atag_offset   = 0x00000100,
+	.init_machine  = nsa310_init,
+	.map_io        = kirkwood_map_io,
+	.init_early    = kirkwood_init_early,
+	.init_irq      = kirkwood_init_irq,
+        .init_time     = kirkwood_timer_init,
+        .restart       = kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/nsa320-setup.c b/arch/arm/mach-kirkwood/nsa320-setup.c
--- a/arch/arm/mach-kirkwood/nsa320-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/nsa320-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,305 @@
+/*
+ * arch/arm/mach-kirkwood/nsa320-setup.c
+ *
+ * ZyXEL NSA320 2-Bay Power Media Server Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/orion-gpio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition nsa320_nand_parts[] = {
+	{
+		.name = "uboot",
+		.offset = 0,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE
+	}, {
+		.name = "uboot_env",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "key_store",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "info",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "etc",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "kernel_1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	}, {
+		.name = "kernel_2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	},
+};
+
+static struct i2c_board_info __initdata nsa320_i2c_rtc = {
+	I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa320_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(1),
+};
+
+static struct mv_sata_platform_data nsa320_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_keys_button nsa320_button_pins[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 36,
+		.desc		= "Reset",
+		.active_low	= 1,
+		.debounce_interval	= 1000,
+	}, {
+		.code		= KEY_COPY,
+		.gpio		= 37,
+		.desc		= "Copy",
+		.active_low	= 1,
+		.debounce_interval	= 1000,
+	}, {
+		.code		= KEY_POWER,
+		.gpio		= 46,
+		.desc		= "Power",
+		.active_low	= 0,
+		.debounce_interval	= 1000,
+	},
+};
+
+static struct gpio_keys_platform_data nsa320_button_data = {
+	.buttons	= nsa320_button_pins,
+	.nbuttons	= ARRAY_SIZE(nsa320_button_pins),
+};
+
+static struct platform_device nsa320_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa320_button_data,
+	},
+};
+
+static struct gpio_led nsa320_led_pins[] = {
+	{
+		.name			= "nsa320:green:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 12,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 13,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:usb",
+		.default_trigger	= "default-off",
+		.gpio			= 15,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:sys",
+		.default_trigger	= "default-off",
+		.gpio			= 28,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:orange:sys",
+		.default_trigger	= "default-on",
+		.gpio			= 29,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 39,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 40,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 41,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 42,
+		.active_low		= 0,
+	},
+};
+
+static int nsa320_gpio_blink_set(unsigned gpio, int state,
+	unsigned long *delay_on, unsigned long *delay_off)
+{
+	switch(state) {
+		case GPIO_LED_NO_BLINK_LOW:
+		case GPIO_LED_NO_BLINK_HIGH:
+			orion_gpio_set_blink(gpio, 0);
+			gpio_set_value(gpio, state);
+		break;
+		case GPIO_LED_BLINK:
+			orion_gpio_set_blink(gpio, 1);
+		break;
+	}
+	return 0;
+}
+
+static struct gpio_led_platform_data nsa320_led_data = {
+	.leds		= nsa320_led_pins,
+	.num_leds	= ARRAY_SIZE(nsa320_led_pins),
+	.gpio_blink_set	= nsa320_gpio_blink_set,
+};
+
+static struct platform_device nsa320_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nsa320_led_data,
+	},
+};
+
+static struct nsa3xx_hwmon_platform_data nsa320_hwmon_data = {
+	/* GPIOs connected to Holtek HT46R065 MCU */
+	.act_pin  = 17,
+	.clk_pin  = 16,
+	.data_pin = 14,
+};
+
+static struct platform_device nsa320_hwmon = {
+	.name		= "nsa3xx-hwmon",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa320_hwmon_data,
+	},
+};
+
+static unsigned int nsa320_mpp_config[] __initdata = {
+	MPP8_TW0_SDA,	/* PCF8563 RTC chip   */
+	MPP9_TW0_SCK,	/* connected to TWSI  */
+	MPP12_GPO,	/* HDD2 LED (green)   */
+	MPP13_GPIO,	/* HDD2 LED (red)     */
+	MPP14_GPIO,	/* MCU DATA pin (in)  */
+	MPP15_GPIO,	/* USB LED (green)    */
+	MPP16_GPIO,	/* MCU CLK pin (out)  */
+	MPP17_GPIO,	/* MCU ACT pin (out)  */
+	MPP21_GPIO,	/* USB power          */
+	MPP28_GPIO,	/* SYS LED (green)    */
+	MPP29_GPIO,	/* SYS LED (orange)   */
+	MPP36_GPIO,	/* reset button       */
+	MPP37_GPIO,	/* copy button        */
+	MPP38_GPIO,	/* VID B0             */
+	MPP39_GPIO,	/* COPY LED (green)   */
+	MPP40_GPIO,	/* COPY LED (red)     */
+	MPP41_GPIO,	/* HDD1 LED (green)   */
+	MPP42_GPIO,	/* HDD1 LED (red)     */
+	MPP43_GPIO,	/* HTP pin            */
+	MPP44_GPIO,	/* buzzer             */
+	MPP45_GPIO,	/* VID B1             */
+	MPP46_GPIO,	/* power button       */
+	MPP47_GPIO,	/* power resume data  */
+	MPP48_GPIO,	/* power off          */
+	MPP49_GPIO,	/* power resume clock */
+	0
+};
+
+#define NSA320_GPIO_USB_POWER	21
+#define NSA320_GPIO_POWER_OFF	48
+
+static void nsa320_power_off(void)
+{
+	gpio_set_value(NSA320_GPIO_POWER_OFF, 1);
+}
+
+static int __initdata usb_power = 1; /* default "on" */
+
+static int __init nsa320_usb_power(char *str)
+{
+	usb_power = strncmp(str, "off", 3) ? 1 : 0;
+	return 1;
+}
+/* Parse boot_command_line string nsa320_usb_power=on|off */
+__setup("nsa320_usb_power=", nsa320_usb_power);
+
+static void __init nsa320_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_mpp_conf(nsa320_mpp_config);
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(nsa320_nand_parts), 40);
+	kirkwood_ge00_init(&nsa320_ge00_data);
+	kirkwood_sata_init(&nsa320_sata_data);
+
+	platform_device_register(&nsa320_leds);
+	platform_device_register(&nsa320_buttons);
+	platform_device_register(&nsa320_hwmon);
+
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, &nsa320_i2c_rtc, 1);
+
+       if (gpio_request(NSA320_GPIO_USB_POWER, "USB Power Enable") ||
+           gpio_direction_output(NSA320_GPIO_USB_POWER, usb_power))
+               pr_err("nsa320: failed to configure USB power enable GPIO)\n");
+       gpio_free(NSA320_GPIO_USB_POWER);
+
+	kirkwood_ehci_init();
+
+	if (gpio_request(NSA320_GPIO_POWER_OFF, "power-off") ||
+	    gpio_direction_output(NSA320_GPIO_POWER_OFF, 0))
+		pr_err("nsa320: failed to configure power-off GPIO\n");
+	else
+		pm_power_off = nsa320_power_off;
+}
+
+MACHINE_START(NSA320, "ZyXEL NSA320 2-Bay Power Media Server")
+	/* Maintainer: Peter Schildmann <linux@schildmann.info> */
+	.atag_offset	= 0x100,
+	.init_machine	= nsa320_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/nsa325-setup.c b/arch/arm/mach-kirkwood/nsa325-setup.c
--- a/arch/arm/mach-kirkwood/nsa325-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/nsa325-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,359 @@
+/*
+ * arch/arm/mach-kirkwood/nsa325-setup.c
+ *
+ * ZyXEL NSA325 2-Bay Power Media Server Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/phy.h>
+#include <linux/marvell_phy.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/pci.h>
+#include <linux/input.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/orion-gpio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition nsa325_nand_parts[] = {
+       {
+               .name = "uboot",
+               .offset = 0,
+               .size = SZ_1M,
+               .mask_flags = MTD_WRITEABLE
+       }, {
+               .name = "uboot_env",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = SZ_512K
+       }, {
+               .name = "key_store",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = SZ_512K
+       }, {
+               .name = "info",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = SZ_512K
+       }, {
+               .name = "etc",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 10 * SZ_1M
+       }, {
+               .name = "kernel_1",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 10 * SZ_1M
+       }, {
+               .name = "rootfs1",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 48 * SZ_1M - SZ_256K
+       }, {
+               .name = "kernel_2",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 10 * SZ_1M
+       }, {
+               .name = "rootfs2",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 48 * SZ_1M - SZ_256K
+       },
+};
+
+static struct i2c_board_info __initdata nsa325_i2c_rtc = {
+       I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa325_ge00_data = {
+       .phy_addr       = MV643XX_ETH_PHY_ADDR(1),
+};
+
+static struct mv_sata_platform_data nsa325_sata_data = {
+       .n_ports        = 2,
+};
+
+static struct gpio_keys_button nsa325_button_pins[] = {
+       {
+               .code           = KEY_RESTART,
+               .gpio           = 36,
+               .desc           = "Reset",
+               .active_low     = 1,
+               .debounce_interval      = 1000,
+       }, {
+               .code           = KEY_COPY,
+               .gpio           = 37,
+               .desc           = "Copy",
+               .active_low     = 1,
+               .debounce_interval      = 1000,
+       }, {
+               .code           = KEY_POWER,
+               .gpio           = 46,
+               .desc           = "Power",
+               .active_low     = 0,
+               .debounce_interval      = 1000,
+       },
+};
+
+static struct gpio_keys_platform_data nsa325_button_data = {
+       .buttons        = nsa325_button_pins,
+       .nbuttons       = ARRAY_SIZE(nsa325_button_pins),
+};
+
+static struct platform_device nsa325_buttons = {
+       .name           = "gpio-keys",
+       .id             = -1,
+       .num_resources  = 0,
+       .dev            = {
+               .platform_data  = &nsa325_button_data,
+       },
+};
+
+static struct gpio_led nsa325_led_pins[] = {
+       {
+               .name                   = "nsa325:green:hdd2",
+               .default_trigger        = "ide-disk",
+               .gpio                   = 12,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:red:hdd2",
+               .default_trigger        = "default-off",
+               .gpio                   = 13,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:usb",
+               .default_trigger        = "default-off",
+               .gpio                   = 15,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:sys",
+               .default_trigger        = "default-off",
+               .gpio                   = 28,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:orange:sys",
+               .default_trigger        = "default-on",
+               .gpio                   = 29,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:copy",
+               .default_trigger        = "default-off",
+               .gpio                   = 39,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:red:copy",
+               .default_trigger        = "default-off",
+               .gpio                   = 40,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:hdd1",
+               .default_trigger        = "ide-disk",
+               .gpio                   = 41,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:red:hdd1",
+               .default_trigger        = "default-off",
+               .gpio                   = 42,
+               .active_low             = 0,
+       },
+};
+
+static int nsa325_gpio_blink_set(unsigned gpio, int state,
+       unsigned long *delay_on, unsigned long *delay_off)
+{
+       switch(state) {
+               case GPIO_LED_NO_BLINK_LOW:
+               case GPIO_LED_NO_BLINK_HIGH:
+                       orion_gpio_set_blink(gpio, 0);
+                       gpio_set_value(gpio, state);
+               break;
+               case GPIO_LED_BLINK:
+                       orion_gpio_set_blink(gpio, 1);
+               break;
+       }
+       return 0;
+}
+
+static struct gpio_led_platform_data nsa325_led_data = {
+       .leds           = nsa325_led_pins,
+       .num_leds       = ARRAY_SIZE(nsa325_led_pins),
+       .gpio_blink_set = nsa325_gpio_blink_set,
+};
+
+static struct platform_device nsa325_leds = {
+       .name   = "leds-gpio",
+       .id     = -1,
+       .dev    = {
+               .platform_data  = &nsa325_led_data,
+       },
+};
+
+static struct nsa3xx_hwmon_platform_data nsa325_hwmon_data = {
+       /* GPIOs connected to Holtek HT46R065 MCU */
+       .act_pin  = 17,
+       .clk_pin  = 16,
+       .data_pin = 14,
+};
+
+static struct platform_device nsa325_hwmon = {
+       .name           = "nsa3xx-hwmon",
+       .id             = -1,
+       .num_resources  = 0,
+       .dev            = {
+               .platform_data  = &nsa325_hwmon_data,
+       },
+};
+
+static unsigned int nsa325_mpp_config[] __initdata = {
+       MPP8_TW0_SDA,   /* PCF8563 RTC chip   */
+       MPP9_TW0_SCK,   /* connected to TWSI  */
+       MPP12_GPO,      /* HDD2 LED (green)   */
+       MPP13_GPIO,     /* ? HDD2 LED (red) ? */
+       MPP14_GPIO,     /* MCU DATA pin (in)  */
+       MPP15_GPIO,     /* USB LED (green)    */
+       MPP16_GPIO,     /* MCU CLK pin (out)  */
+       MPP17_GPIO,     /* MCU ACT pin (out)  */
+       MPP21_GPIO,     /* USB power          */
+       MPP28_GPIO,     /* SYS LED (green)    */
+       MPP29_GPIO,     /* SYS LED (orange)   */
+       MPP36_GPIO,     /* reset button       */
+       MPP37_GPIO,     /* copy button        */
+       MPP38_GPIO,     /* VID B0             */
+       MPP39_GPIO,     /* COPY LED (green)   */
+       MPP40_GPIO,     /* COPY LED (red)     */
+       MPP41_GPIO,     /* HDD1 LED (green)   */
+       MPP42_GPIO,     /* HDD1 LED (red)     */
+       MPP43_GPIO,     /* HTP pin            */
+       MPP44_GPIO,     /* buzzer             */
+       MPP45_GPIO,     /* VID B1             */
+       MPP46_GPIO,     /* power button       */
+       MPP47_GPIO,     /* HDD2 power         */
+       MPP48_GPIO,     /* power off          */
+       0
+};
+
+#define NSA325_GPIO_WATCHDOG   14
+#define NSA325_GPIO_USB_POWER  21
+#define NSA325_GPIO_HDD2_POWER 47
+#define NSA325_GPIO_POWER_OFF  48
+
+static void nsa325_power_off(void)
+{
+       gpio_set_value(NSA325_GPIO_POWER_OFF, 1);
+}
+
+static int __initdata usb_power = 1; /* default "on" */
+
+static int __init nsa325_usb_power(char *str)
+{
+       usb_power = strncmp(str, "off", 3) ? 1 : 0;
+       return 1;
+}
+/* Parse boot_command_line string nsa325_usb_power=on|off */
+__setup("nsa325_usb_power=", nsa325_usb_power);
+
+/* the nsa325 uses the 88E1310S Alaska, and has an MCU attached to the LED[2] via tristate interrupt */
+static int nsa325_phy_fixup(struct phy_device *phydev)
+{
+       int err;
+       int temp;
+       /* go to page 3 */
+       err = phy_write(phydev, 22, 3);
+       if (err < 0)
+           return err;
+       /* read page 3, register 17 */
+       temp = phy_read(phydev, 17);
+       /* clear bit 4, set bit 5 */
+       temp &= ~(1<<4);
+       temp |= (1<<5);
+       /* write page 3, register 17 */
+       err = phy_write(phydev, 17, temp);
+       if (err < 0)
+           return err;
+       /* go to page 0 */
+       err = phy_write(phydev, 22, 0);
+       if (err < 0)
+           return err;
+
+       return 0;
+}
+
+static void __init nsa325_init(void)
+{
+       /*
+        * Basic setup. Needs to be called early.
+        */
+       kirkwood_init();
+
+       kirkwood_mpp_conf(nsa325_mpp_config);
+
+       /* setup the phy fixup */
+       phy_register_fixup_for_uid(MARVELL_PHY_ID_88E1318S,MARVELL_PHY_ID_MASK,nsa325_phy_fixup);
+       kirkwood_ge00_init(&nsa325_ge00_data);
+
+       kirkwood_uart0_init();
+       kirkwood_nand_init(ARRAY_AND_SIZE(nsa325_nand_parts), 40);
+
+       /* turn off the watchdog */
+       gpio_set_value(NSA325_GPIO_WATCHDOG, 1);
+
+       /* turn on the second drive bay */
+       if (gpio_request(NSA325_GPIO_HDD2_POWER, "HDD2 Power Enable") ||
+           gpio_direction_output(NSA325_GPIO_HDD2_POWER,1))
+               pr_err("nsa325: failed to configure HDD2 power enable GPIO\n");
+       gpio_free(NSA325_GPIO_HDD2_POWER);
+
+       kirkwood_sata_init(&nsa325_sata_data);
+
+       platform_device_register(&nsa325_leds);
+       platform_device_register(&nsa325_buttons);
+       platform_device_register(&nsa325_hwmon);
+
+       kirkwood_i2c_init();
+       i2c_register_board_info(0, &nsa325_i2c_rtc, 1);
+
+       if (gpio_request(NSA325_GPIO_USB_POWER, "USB Power Enable") ||
+           gpio_direction_output(NSA325_GPIO_USB_POWER, usb_power))
+               pr_err("nsa325: failed to configure USB power enable GPIO\n");
+       gpio_free(NSA325_GPIO_USB_POWER);
+
+       kirkwood_ehci_init();
+
+       if (gpio_request(NSA325_GPIO_POWER_OFF, "power-off") ||
+           gpio_direction_output(NSA325_GPIO_POWER_OFF, 0))
+               pr_err("nsa325: failed to configure power-off GPIO\n");
+       else
+               pm_power_off = nsa325_power_off;
+}
+
+static int __init nsa325_pci_init(void)
+{
+        if (machine_is_nsa325())
+                kirkwood_pcie_init(KW_PCIE0);
+
+        return 0;
+}
+subsys_initcall(nsa325_pci_init);
+
+MACHINE_START(NSA325, "ZyXEL NSA325 2-Bay Power Media Server")
+       /* Maintainer: Jason Plum <max@warheads.net> */
+        .atag_offset    = 0x00000100,
+	.init_machine	= nsa325_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+        .init_time      = kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/pogo_e02-setup.c b/arch/arm/mach-kirkwood/pogo_e02-setup.c
--- a/arch/arm/mach-kirkwood/pogo_e02-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/pogo_e02-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,115 @@
+/*
+ * arch/arm/mach-kirkwood/pogo_e02-setup.c
+ *
+ * CloudEngines Pogoplug E02 support
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition pogo_e02_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data pogo_e02_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct gpio_led pogo_e02_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 49,
+		.active_low		= 1,
+	}
+};
+
+static struct gpio_led_platform_data pogo_e02_led_data = {
+	.leds		= pogo_e02_led_pins,
+	.num_leds	= ARRAY_SIZE(pogo_e02_led_pins),
+};
+
+static struct platform_device pogo_e02_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pogo_e02_led_data,
+	}
+};
+
+static unsigned int pogo_e02_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Orange */
+	0
+};
+
+static void __init pogo_e02_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(pogo_e02_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(pogo_e02_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&pogo_e02_ge00_data);
+
+	platform_device_register(&pogo_e02_leds);
+}
+
+MACHINE_START(POGO_E02, "Pogoplug E02")
+	.atag_offset	= 0x00000100,
+	.init_machine	= pogo_e02_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/pogoplugv4-setup.c b/arch/arm/mach-kirkwood/pogoplugv4-setup.c
--- a/arch/arm/mach-kirkwood/pogoplugv4-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/pogoplugv4-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,197 @@
+/*
+ * arch/arm/mach-kirkwood/pogoplugv4-setup.c
+ *
+ * Pogoplug Series 4 Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+/*#include <linux/spi/orion_spi.h> */
+#include <linux/input.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+#define POGOPLUGV4_GPIO_USB_VBUS		10
+
+static struct mtd_partition ppv4_nand_parts[] = {
+	{
+		.name	= "u-boot",
+		.offset	= 0,
+		.size	= 2 * SZ_1M
+	}, {
+		.name	= "uImage",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 3 * SZ_1M
+	}, {
+		.name	= "uImage2",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 3 * SZ_1M
+	}, {
+		.name	= "failsafe",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= SZ_8M
+	}, {
+		.name	= "root",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data pogoplugv4_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data pogoplugv4_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct gpio_keys_button pogoplugv4_button_pins[] = {
+	{
+		.code		= KEY_EJECTCD,
+		.gpio		= 29,
+		.desc		= "Eject Button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data pogoplugv4_button_data = {
+	.buttons	= pogoplugv4_button_pins,
+	.nbuttons	= ARRAY_SIZE(pogoplugv4_button_pins),
+};
+
+static struct platform_device pogoplugv4_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,   
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data  = &pogoplugv4_button_data,
+	},
+};
+
+static struct gpio_led pogoplugv4_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 22,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 24,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data pogoplugv4_led_data = {
+	.leds		= pogoplugv4_led_pins,
+	.num_leds	= ARRAY_SIZE(pogoplugv4_led_pins),
+};
+
+static struct platform_device pogoplugv4_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pogoplugv4_led_data,
+	}
+};
+
+static struct mvsdio_platform_data ppv4_mvsdio_data = {
+	.gpio_card_detect = 27,
+};
+
+static unsigned int ppv4_mpp_config[] __initdata = {
+	MPP27_GPIO,	/* SD card detect */
+	MPP29_GPIO,	/* Eject button */
+	MPP22_GPIO,	/* Green LED */
+	MPP24_GPIO,	/* Red LED */
+	MPP12_SD_CLK,
+	MPP13_SD_CMD,
+	MPP14_SD_D0,
+	MPP15_SD_D1,
+	MPP16_SD_D2,
+	MPP17_SD_D3,
+	0
+};
+
+static const struct flash_platform_data pogoplugv4_spi_slave_data = {
+	.type		= "m25p05-nonjedec",
+};
+
+static struct spi_board_info __initdata pogoplugv4_spi_slave_info[] = {
+	{
+		.modalias	= "m25p05-nonjedec",
+		.platform_data	= &pogoplugv4_spi_slave_data,
+		.irq		= -1,
+		.max_speed_hz	= 20000000,
+		.bus_num	= 0,
+		.chip_select	= 0,
+	},
+};
+
+static void __init pogoplugv4_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(ppv4_mpp_config);
+
+	/* 
+	 * orion_gpio_set_valid(POGOPLUGV4_GPIO_USB_VBUS, 1);
+	 */
+	if (gpio_request(POGOPLUGV4_GPIO_USB_VBUS, "USB VBUS") != 0 ||
+	    gpio_direction_output(POGOPLUGV4_GPIO_USB_VBUS, 1) != 0)
+		pr_err("POGOPLUGV4: failed to setup USB VBUS GPIO\n");
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&pogoplugv4_ge00_data);
+	kirkwood_sata_init(&pogoplugv4_sata_data);
+	spi_register_board_info(pogoplugv4_spi_slave_info,
+				ARRAY_SIZE(pogoplugv4_spi_slave_info));
+	kirkwood_spi_init();
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(ppv4_nand_parts), 40);
+	kirkwood_sdio_init(&ppv4_mvsdio_data);
+	platform_device_register(&pogoplugv4_leds);
+	platform_device_register(&pogoplugv4_buttons);
+}
+
+static int __init pogoplugv4_pci_init(void)
+{
+	if (machine_is_pogoplugv4())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(pogoplugv4_pci_init);
+
+MACHINE_START(POGOPLUGV4, "Pogoplug V4")
+	/* Maintainer: Kevin Mihelich <kevin@archlinuxarm.org> */
+	.atag_offset	= 0x00000100,
+	.init_machine	= pogoplugv4_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/mach-kirkwood/sheevaplug-setup.c b/arch/arm/mach-kirkwood/sheevaplug-setup.c
--- a/arch/arm/mach-kirkwood/sheevaplug-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/sheevaplug-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,170 @@
+/*
+ * arch/arm/mach-kirkwood/sheevaplug-setup.c
+ *
+ * Marvell SheevaPlug Reference Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition sheevaplug_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data sheevaplug_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data sheeva_esata_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct mvsdio_platform_data sheevaplug_mvsdio_data = {
+	/* unfortunately the CD signal has not been connected */
+};
+
+static struct mvsdio_platform_data sheeva_esata_mvsdio_data = {
+	.gpio_write_protect = 44, /* MPP44 used as SD write protect */
+	.gpio_card_detect = 47,	  /* MPP47 used as SD card detect */
+};
+
+static struct gpio_led sheevaplug_led_pins[] = {
+	{
+		.name			= "plug:red:misc",
+		.default_trigger	= "none",
+		.gpio			= 46,
+		.active_low		= 1,
+	},
+	{
+		.name           	= "status:green:health",
+		.default_trigger    	= "none",
+		.gpio           	= 48,
+		.active_low     	= 1,
+	},
+	{
+		.name           	= "status:blue:health",
+		.default_trigger	= "default-on",
+		.gpio			= 49,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data sheevaplug_led_data = {
+	.leds		= sheevaplug_led_pins,
+	.num_leds	= ARRAY_SIZE(sheevaplug_led_pins),
+};
+
+static struct platform_device sheevaplug_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &sheevaplug_led_data,
+	}
+};
+
+static unsigned int sheevaplug_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP46_GPIO,	/* LED Red */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Blue */
+	0
+};
+
+static unsigned int sheeva_esata_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP44_GPIO,	/* SD Write Protect */
+	MPP47_GPIO,	/* SD Card Detect */
+	MPP46_GPIO,	/* LED Red */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Blue */
+	0
+};
+
+static void __init sheevaplug_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	if (machine_is_esata_sheevaplug())
+		kirkwood_mpp_conf(sheeva_esata_mpp_config);
+	else
+		kirkwood_mpp_conf(sheevaplug_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(sheevaplug_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		pr_err("can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&sheevaplug_ge00_data);
+
+	/* honor lower power consumption for plugs with out eSATA */
+	if (machine_is_esata_sheevaplug())
+		kirkwood_sata_init(&sheeva_esata_sata_data);
+
+	/* enable sd wp and sd cd on plugs with esata */
+	if (machine_is_esata_sheevaplug())
+		kirkwood_sdio_init(&sheeva_esata_mvsdio_data);
+	else
+		kirkwood_sdio_init(&sheevaplug_mvsdio_data);
+
+	platform_device_register(&sheevaplug_leds);
+}
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+MACHINE_START(SHEEVAPLUG, "Marvell SheevaPlug Reference Board")
+	/* Maintainer: shadi Ammouri <shadi@marvell.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= sheevaplug_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
+#endif
+
+#ifdef CONFIG_MACH_ESATA_SHEEVAPLUG
+MACHINE_START(ESATA_SHEEVAPLUG, "Marvell eSATA SheevaPlug Reference Board")
+	.atag_offset	= 0x100,
+	.init_machine	= sheevaplug_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
+#endif
diff -Naur a/arch/arm/mach-kirkwood/topkick-setup.c b/arch/arm/mach-kirkwood/topkick-setup.c
--- a/arch/arm/mach-kirkwood/topkick-setup.c	1969-12-31 16:00:00.000000000 -0800
+++ b/arch/arm/mach-kirkwood/topkick-setup.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,165 @@
+/*
+ * arch/arm/mach-kirkwood/topkick-setup.c
+ *
+ * USI Topkick Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition topkick_nand_parts[] = {
+	{
+		.name	= "u-boot",
+		.offset	= 0,
+		.size	= 0x180000
+	}, {
+		.name	= "u-boot-env",
+		.offset	= 0x180000,
+		.size	= 128 * 1024
+	}, {
+		.name	= "uImage",
+		.offset	= 2 * 1024 * 1024,
+		.size	= 6 * 1024 * 1024
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data topkick_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data topkick_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct mvsdio_platform_data topkick_mvsdio_data = {
+	.gpio_card_detect = 47, /* MPP47 used as SD card detect */
+};
+
+
+static struct gpio_led topkick_led_pins[] = {
+	{
+		.name			= "status:blue:disk",
+		.default_trigger	= "none",
+		.gpio			= 21,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 37,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:blue:health",
+		.default_trigger	= "default-on",
+		.gpio			= 38,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:green:misc",
+		.default_trigger	= "none",
+		.gpio			= 39,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:misc",
+		.default_trigger	= "none",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data topkick_led_data = {
+	.leds		= topkick_led_pins,
+	.num_leds	= ARRAY_SIZE(topkick_led_pins),
+};
+
+static struct platform_device topkick_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &topkick_led_data,
+	}
+};
+
+static unsigned int topkick_mpp_config[] __initdata = {
+	MPP12_SD_CLK,	/* SDIO Clock */
+	MPP13_SD_CMD,	/* SDIO Cmd */
+	MPP14_SD_D0,	/* SDIO Data 0 */
+	MPP15_SD_D1,	/* SDIO Data 1 */
+	MPP16_SD_D2,	/* SDIO Data 2 */
+	MPP17_SD_D3,	/* SDIO Data 3 */
+	MPP21_GPIO,	/* LED Blue SATA */
+	MPP35_GPIO,	/* USB Power Enable */
+	MPP36_GPIO,	/* SATA Power Enable */
+	MPP37_GPIO,	/* LED Red  System */
+	MPP38_GPIO,	/* LED Blue System */
+	MPP39_GPIO,	/* LED Green Misc/WiFi */
+	MPP43_GPIO,	/* WOL Eth WOL */
+	MPP44_GPIO,	/* SW GW Mode */
+	MPP45_GPIO,	/* SW AP Mode */
+	MPP46_GPIO,	/* SW Power Off */
+	MPP47_GPIO,	/* SDIO Detect */
+	MPP48_GPIO,	/* LED Orange Misc/WiFi */
+	0
+};
+
+static void __init topkick_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(topkick_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(topkick_nand_parts), 40);
+
+	if (gpio_request(35, "USB Power Enable") != 0 ||
+	    gpio_direction_output(35, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 35 (USB Power Enable)\n");
+	if (gpio_request(36, "SATA Power Enable") != 0 ||
+	    gpio_direction_output(36, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 36 (SATA Power Enable)\n");
+	kirkwood_ge00_init(&topkick_ge00_data);
+	kirkwood_ehci_init();
+	kirkwood_sata_init(&topkick_sata_data);
+	kirkwood_sdio_init(&topkick_mvsdio_data);
+
+	platform_device_register(&topkick_leds);
+}
+
+MACHINE_START(TOPKICK, "USI Topkick")
+	/* Maintainer: Mike Brown <mbrown@archlinuxarm.org> */
+	.atag_offset	= 0x100,
+	.init_machine	= topkick_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.init_time	= kirkwood_timer_init,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -Naur a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c
--- a/arch/arm/plat-orion/common.c	2014-03-30 20:40:15.000000000 -0700
+++ b/arch/arm/plat-orion/common.c	2014-03-31 00:25:00.000000000 -0700
@@ -257,7 +257,9 @@
 /*****************************************************************************
  * GE00
  ****************************************************************************/
-static struct mv643xx_eth_shared_platform_data orion_ge00_shared_data;
+struct mv643xx_eth_shared_platform_data orion_ge00_shared_data = {
+	.tx_csum_limit	= 1600,
+};
 
 static struct resource orion_ge00_shared_resources[] = {
 	{
diff -Naur a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
--- a/arch/arm/tools/mach-types	2014-03-30 20:40:15.000000000 -0700
+++ b/arch/arm/tools/mach-types	2014-03-31 21:20:47.000000000 -0700
@@ -1007,3 +1007,12 @@
 eukrea_cpuimx28sd	MACH_EUKREA_CPUIMX28SD	EUKREA_CPUIMX28SD	4573
 domotab			MACH_DOMOTAB		DOMOTAB			4574
 pfla03			MACH_PFLA03		PFLA03			4575
+goflexnet		MACH_GOFLEXNET		GOFLEXNET		3089
+goflexhome		MACH_GOFLEXHOME		GOFLEXHOME		3338
+iconnect		MACH_ICONNECT		ICONNECT		2870
+pogo_e02		MACH_POGO_E02		POGO_E02		3542
+nsa320			MACH_NSA320		NSA320			3956
+pogoplugv4		MACH_POGOPLUGV4		POGOPLUGV4		3960
+pogoplugv3		MACH_POGOPLUGV3		POGOPLUGV3		3973
+pogoplugv3pci		MACH_POGOPLUGV3PCI	POGOPLUGV3PCI		3976
+nsa310			MACH_NSA310		NSA310			4022
diff -Naur a/build-3.14-tld-2-debug-kernel.log b/build-3.14-tld-2-debug-kernel.log
diff -Naur a/.config b/.config
diff -Naur a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
--- a/drivers/ata/sata_mv.c	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/ata/sata_mv.c	2014-04-19 00:17:50.000000000 -0700
@@ -1,6 +1,7 @@
 /*
  * sata_mv.c - Marvell SATA support
  *
+ * Copyright 2013 bodhi
  * Copyright 2008-2009: Marvell Corporation, all rights reserved.
  * Copyright 2005: EMC Corporation, all rights reserved.
  * Copyright 2005 Red Hat, Inc.  All rights reserved.
@@ -72,6 +73,7 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <linux/libata.h>
+#include <linux/leds.h>
 
 #define DRV_NAME	"sata_mv"
 #define DRV_VERSION	"1.28"
@@ -1170,6 +1172,8 @@
 {
 	int want_ncq = (protocol == ATA_PROT_NCQ);
 
+        ledtrig_ide_activity(ap->port_no);
+
 	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
 		int using_ncq = ((pp->pp_flags & MV_PP_FLAG_NCQ_EN) != 0);
 		if (want_ncq != using_ncq)
diff -Naur a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
--- a/drivers/hwmon/Kconfig	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/hwmon/Kconfig	2014-03-31 21:20:47.000000000 -0700
@@ -1556,6 +1556,19 @@
         help
           Support for the A/D converter on MC13783 and MC13892 PMIC.
 
+config SENSORS_NSA3XX
+	tristate "ZyXEL NSA3xx fan speed and temperature sensors"
+	depends on (MACH_NSA310 || MACH_NSA320) && GPIOLIB
+	help
+	  If you say yes here you get support for hardware monitoring
+	  for the ZyXEL NSA3XX Media Servers.
+
+	  The sensor data is taken from a Holtek HT46R065 microcontroller
+	  connected to GPIO lines.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called nsa3xx-hwmon.
+
 if ACPI
 
 comment "ACPI drivers"
diff -Naur a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
--- a/drivers/hwmon/Makefile	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/hwmon/Makefile	2014-03-31 21:20:47.000000000 -0700
@@ -109,6 +109,7 @@
 obj-$(CONFIG_SENSORS_MAX6650)	+= max6650.o
 obj-$(CONFIG_SENSORS_MAX6697)	+= max6697.o
 obj-$(CONFIG_SENSORS_MC13783_ADC)+= mc13783-adc.o
+obj-$(CONFIG_SENSORS_NSA3XX)	+= nsa3xx-hwmon.o
 obj-$(CONFIG_SENSORS_MCP3021)	+= mcp3021.o
 obj-$(CONFIG_SENSORS_NCT6775)	+= nct6775.o
 obj-$(CONFIG_SENSORS_NTC_THERMISTOR)	+= ntc_thermistor.o
diff -Naur a/drivers/hwmon/nsa3xx-hwmon.c b/drivers/hwmon/nsa3xx-hwmon.c
--- a/drivers/hwmon/nsa3xx-hwmon.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/hwmon/nsa3xx-hwmon.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,251 @@
+/*
+ * drivers/hwmon/nsa3xx-hwmon.c
+ *
+ * ZyXEL NSA3xx Media Servers
+ * hardware monitoring
+ *
+ * Copyright (C) 2012 Peter Schildmann <linux@schildmann.info>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+
+#define MAGIC_NUMBER 0x55
+
+struct nsa3xx_hwmon {
+	struct platform_device	*pdev;
+	struct device		*classdev;
+	struct mutex		update_lock;	/* lock GPIO operations */
+	unsigned long		last_updated;	/* jiffies */
+	unsigned long		mcu_data;
+};
+
+enum nsa3xx_inputs {
+	NSA3XX_FAN = 1,
+	NSA3XX_TEMP = 0,
+};
+
+static const char *nsa3xx_input_names[] = {
+	[NSA3XX_FAN] = "Chassis Fan",
+	[NSA3XX_TEMP] = "System Temperature",
+};
+
+static unsigned long nsa3xx_hwmon_update(struct device *dev)
+{
+	int i;
+	unsigned long mcu_data;
+	struct nsa3xx_hwmon *hwmon = dev_get_drvdata(dev);
+	struct nsa3xx_hwmon_platform_data *pdata = hwmon->pdev->dev.platform_data;
+
+	mutex_lock(&hwmon->update_lock);
+
+	mcu_data = hwmon->mcu_data;
+
+	if (time_after(jiffies, hwmon->last_updated + (3 * HZ)) || mcu_data == 0) {
+		dev_dbg(dev, "Reading MCU data\n");
+
+		gpio_set_value(pdata->act_pin, 0);
+		msleep(100);
+
+		for (i = 31; i >= 0; i--) {
+			gpio_set_value(pdata->clk_pin, 0);
+			udelay(100);
+
+			gpio_set_value(pdata->clk_pin, 1);
+			udelay(100);
+
+			mcu_data |= gpio_get_value(pdata->data_pin) ? (1 << i) : 0;
+		}
+
+		gpio_set_value(pdata->act_pin, 1);
+
+		if ((mcu_data & 0xff000000) != (MAGIC_NUMBER << 24)) {
+			dev_err(dev, "Failed to read MCU data\n");
+			mcu_data = 0;
+		}
+
+		hwmon->mcu_data = mcu_data;
+		hwmon->last_updated = jiffies;
+	}
+
+	mutex_unlock(&hwmon->update_lock);
+
+	return mcu_data;
+}
+
+static ssize_t show_name(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "nsa3xx\n");
+}
+
+static ssize_t show_label(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	int channel = to_sensor_dev_attr(attr)->index;
+	return sprintf(buf, "%s\n", nsa3xx_input_names[channel]);
+}
+
+static ssize_t show_value(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	int channel = to_sensor_dev_attr(attr)->index;
+	unsigned long mcu_data = nsa3xx_hwmon_update(dev);
+	unsigned long value = 0;
+	switch(channel) {
+	case NSA3XX_TEMP:
+		value = (mcu_data & 0xffff) * 100;
+		break;
+	case NSA3XX_FAN:
+		value = ((mcu_data & 0xff0000) >> 16) * 100;
+		break;
+	}
+	return sprintf(buf, "%lu\n", value);
+}
+
+static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_label, NULL, NSA3XX_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_value, NULL, NSA3XX_TEMP);
+static SENSOR_DEVICE_ATTR(fan1_label, S_IRUGO, show_label, NULL, NSA3XX_FAN);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_value, NULL, NSA3XX_FAN);
+
+static struct attribute *nsa3xx_attributes[] = {
+	&dev_attr_name.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_label.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group nsa3xx_attr_group = {
+	.attrs	= nsa3xx_attributes,
+};
+
+static int nsa3xx_hwmon_request_gpios(struct nsa3xx_hwmon_platform_data *pdata)
+{
+	int ret;
+
+	if ((ret = gpio_request(pdata->act_pin, "act pin")))
+		return ret;
+
+	if ((ret = gpio_request(pdata->clk_pin, "clk pin")))
+		return ret;
+
+	if ((ret = gpio_request(pdata->data_pin, "data pin")))
+		return ret;
+
+	if ((ret = gpio_direction_output(pdata->act_pin, 1)))
+		return ret;
+
+	if ((ret = gpio_direction_output(pdata->clk_pin, 1)))
+		return ret;
+
+	if ((ret = gpio_direction_input(pdata->data_pin)))
+		return ret;
+
+	return 0;
+}
+
+static void nsa3xx_hwmon_free_gpios(struct nsa3xx_hwmon_platform_data *pdata)
+{
+	gpio_free(pdata->act_pin);
+	gpio_free(pdata->clk_pin);
+	gpio_free(pdata->data_pin);
+}
+
+static int nsa3xx_hwmon_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct nsa3xx_hwmon *hwmon;
+	struct nsa3xx_hwmon_platform_data *pdata = pdev->dev.platform_data;
+
+	hwmon = kzalloc(sizeof(struct nsa3xx_hwmon), GFP_KERNEL);
+	if (!hwmon)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, hwmon);
+	hwmon->pdev = pdev;
+	hwmon->mcu_data = 0;
+	mutex_init(&hwmon->update_lock);
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+	if (ret)
+		goto err;
+
+	hwmon->classdev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon->classdev)) {
+		ret = PTR_ERR(hwmon->classdev);
+		goto err_sysfs;
+	}
+
+	ret = nsa3xx_hwmon_request_gpios(pdata);
+	if (ret)
+		goto err_free_gpio;
+
+	dev_info(&pdev->dev, "initialized\n");
+
+	return 0;
+
+err_free_gpio:
+	nsa3xx_hwmon_free_gpios(pdata);
+	hwmon_device_unregister(hwmon->classdev);
+err_sysfs:
+	sysfs_remove_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+err:
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+	return ret;
+}
+
+static int nsa3xx_hwmon_remove(struct platform_device *pdev)
+{
+	struct nsa3xx_hwmon *hwmon = platform_get_drvdata(pdev);
+
+	nsa3xx_hwmon_free_gpios(pdev->dev.platform_data);
+	hwmon_device_unregister(hwmon->classdev);
+	sysfs_remove_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+
+	return 0;
+}
+
+static struct platform_driver nsa3xx_hwmon_driver = {
+	.probe = nsa3xx_hwmon_probe,
+	.remove = nsa3xx_hwmon_remove,
+	.driver = {
+		.name = "nsa3xx-hwmon",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(nsa3xx_hwmon_driver);
+
+MODULE_AUTHOR("Peter Schildmann <linux@schildmann.info>");
+MODULE_DESCRIPTION("NSA3XX Hardware Monitoring");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nsa3xx-hwmon");
diff -Naur a/drivers/ide/ide-probe.c b/drivers/ide/ide-probe.c
--- a/drivers/ide/ide-probe.c	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/ide/ide-probe.c	2014-04-19 00:19:02.000000000 -0700
@@ -206,6 +206,7 @@
 	printk(KERN_INFO "%s: dumping identify data\n", drive->name);
 	ide_dump_identify((u8 *)id);
 #endif
+
 	ide_fix_driveid(id);
 
 	/*
diff -Naur a/drivers/leds/Kconfig b/drivers/leds/Kconfig
--- a/drivers/leds/Kconfig	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/leds/Kconfig	2014-03-31 21:20:47.000000000 -0700
@@ -487,6 +487,106 @@
 	  This option enables support for the BlinkM RGB LED connected
 	  through I2C. Say Y to enable support for the BlinkM LED.
 
+config LEDS_TRIGGERS
+ 	bool "LED Trigger support"
+ 	depends on LEDS_CLASS
+ 	help
+ 	  This option enables trigger support for the leds class.
+ 	  These triggers allow kernel events to drive the LEDs and can
+ 	  be configured via sysfs. If unsure, say Y.
+ 
+ 
+ config LEDS_TRIGGER_TIMER
+ 	tristate "LED Timer Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to be controlled by a programmable timer
+ 	  via sysfs. Some LED hardware can be programmed to start
+ 	  blinking the LED without any further software interaction.
+ 	  For more details read Documentation/leds/leds-class.txt.
+ 
+ 	  If unsure, say Y.
+ 
+ config LEDS_TRIGGER_ONESHOT
+ 	tristate "LED One-shot Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to blink in one-shot pulses with parameters
+ 	  controlled via sysfs.  It's useful to notify the user on
+ 	  sporadic events, when there are no clear begin and end trap points,
+ 	  or on dense events, where this blinks the LED at constant rate if
+ 	  rearmed continuously.
+ 
+ 	  It also shows how to use the led_blink_set_oneshot() function.
+ 
+ 	  If unsure, say Y.
+ 
+ config LEDS_TRIGGER_IDE_DISK
+ 	bool "LED IDE Disk Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to be controlled by IDE disk activity.
+ 	  If unsure, say Y.
+ 
+ config LEDS_TRIGGER_HEARTBEAT
+ 	tristate "LED Heartbeat Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to be controlled by a CPU load average.
+ 	  The flash frequency is a hyperbolic function of the 1-minute
+ 	  load average.
+ 	  If unsure, say Y.
+ 
+ config LEDS_TRIGGER_BACKLIGHT
+ 	tristate "LED backlight Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to be controlled as a backlight device: they
+ 	  turn off and on when the display is blanked and unblanked.
+ 
+ 	  If unsure, say N.
+ 
+ config LEDS_TRIGGER_CPU
+ 	bool "LED CPU Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to be controlled by active CPUs. This shows
+ 	  the active CPUs across an array of LEDs so you can see which
+ 	  CPUs are active on the system at any given moment.
+ 
+ 	  If unsure, say N.
+ 
+ config LEDS_TRIGGER_GPIO
+ 	tristate "LED GPIO Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	depends on GPIOLIB
+ 	help
+ 	  This allows LEDs to be controlled by gpio events. It's good
+ 	  when using gpios as switches and triggering the needed LEDs
+ 	  from there. One use case is n810's keypad LEDs that could
+ 	  be triggered by this trigger when user slides up to show
+ 	  keypad.
+ 
+ 	  If unsure, say N.
+ 
+ config LEDS_TRIGGER_DEFAULT_ON
+ 	tristate "LED Default ON Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows LEDs to be initialised in the ON state.
+ 	  If unsure, say Y.
+ 
+ comment "iptables trigger is under Netfilter config (LED target)"
+ 	depends on LEDS_TRIGGERS
+ 
+ config LEDS_TRIGGER_TRANSIENT
+ 	tristate "LED Transient Trigger"
+ 	depends on LEDS_TRIGGERS
+ 	help
+ 	  This allows one time activation of a transient state on
+ 	  GPIO/PWM based hardware.
+ 	  If unsure, say Y
+
 comment "LED Triggers"
 source "drivers/leds/trigger/Kconfig"
 
diff -Naur a/drivers/leds/trigger/ledtrig-ide-disk.c b/drivers/leds/trigger/ledtrig-ide-disk.c
--- a/drivers/leds/trigger/ledtrig-ide-disk.c	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/leds/trigger/ledtrig-ide-disk.c	2014-03-31 21:20:47.000000000 -0700
@@ -1,8 +1,9 @@
 /*
  * LED IDE-Disk Activity Trigger
  *
- * Copyright 2006 Openedhand Ltd.
+/* Copyright 2013 bodhi
  *
+ * Copyright 2006 Openedhand Ltd.
  * Author: Richard Purdie <rpurdie@openedhand.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -18,25 +19,36 @@
 
 #define BLINK_DELAY 30
 
-DEFINE_LED_TRIGGER(ledtrig_ide);
+DEFINE_LED_TRIGGER(ledtrig_ide1);
+DEFINE_LED_TRIGGER(ledtrig_ide2);
 static unsigned long ide_blink_delay = BLINK_DELAY;
 
-void ledtrig_ide_activity(void)
+void ledtrig_ide_activity(int portno)
 {
-	led_trigger_blink_oneshot(ledtrig_ide,
-				  &ide_blink_delay, &ide_blink_delay, 0);
+	switch (portno) {
+		case 0:
+		        led_trigger_blink_oneshot(ledtrig_ide1, &ide_blink_delay, &ide_blink_delay, 0);
+			break;
+        	case 1:
+			led_trigger_blink_oneshot(ledtrig_ide2, &ide_blink_delay, &ide_blink_delay, 0);
+			break;
+		default:
+			break;
+	}
 }
 EXPORT_SYMBOL(ledtrig_ide_activity);
 
 static int __init ledtrig_ide_init(void)
 {
-	led_trigger_register_simple("ide-disk", &ledtrig_ide);
+	led_trigger_register_simple("ide-disk1", &ledtrig_ide1); 
+	led_trigger_register_simple("ide-disk2", &ledtrig_ide2);
 	return 0;
 }
 
 static void __exit ledtrig_ide_exit(void)
 {
-	led_trigger_unregister_simple(ledtrig_ide);
+	led_trigger_unregister_simple(ledtrig_ide1);
+	led_trigger_unregister_simple(ledtrig_ide2);
 }
 
 module_init(ledtrig_ide_init);
diff -Naur a/drivers/media/dvb-frontends/ds3103.c b/drivers/media/dvb-frontends/ds3103.c
--- a/drivers/media/dvb-frontends/ds3103.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/media/dvb-frontends/ds3103.c	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,1395 @@
+/*
+    Montage Technology DS3103 - DVBS/S2 Demodulator driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+
+#include "dvb_frontend.h"
+#include "ds3103.h"
+
+static int debug;
+
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(args); \
+	} while (0)
+
+#define DS3103_DEFAULT_FIRMWARE "dvb-fe-ds3103.fw"
+
+static u8 ds310x_dvbs_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x03,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x31, 0x40,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x30,
+	0x65, 0x40,
+	0x68, 0x26,
+	0x69, 0x4c,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x7c, 0x00,
+	0xae, 0x82,
+	0x80, 0x64,
+	0x81, 0x66,
+	0x82, 0x44,
+	0x85, 0x04,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xe0, 0xf8,
+	0xe6, 0x8b,
+	0xd0, 0x40,
+	0xf8, 0x20,
+	0xfa, 0x0f,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00
+};
+
+static u8 ds310x_dvbs2_init_tab[] = {
+	0x23, 0x07,
+	0x08, 0x07,
+	0x0c, 0x02,
+	0x21, 0x54,
+	0x25, 0x82,
+	0x27, 0x31,
+	0x30, 0x08,
+	0x32, 0x32,
+	0x33, 0x35,
+	0x35, 0xff,
+	0x3a, 0x00,
+	0x37, 0x10,
+	0x38, 0x10,
+	0x39, 0x02,
+	0x42, 0x60,
+	0x4a, 0x80,
+	0x4b, 0x04,
+	0x4d, 0x91,
+	0x5d, 0xc8,
+	0x50, 0x36,
+	0x51, 0x36,
+	0x52, 0x36,
+	0x53, 0x36,
+	0x63, 0x0f,
+	0x64, 0x10,
+	0x65, 0x20,
+	0x68, 0x46,
+	0x69, 0xcd,
+	0x70, 0x20,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x40,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x60,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x80,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0xa0,
+	0x71, 0x70,
+	0x72, 0x04,
+	0x73, 0x00,
+	0x70, 0x1f,
+	0x76, 0x38,
+	0x77, 0xa6,
+	0x78, 0x0c,
+	0x79, 0x80,
+	0x7f, 0x14,
+	0x85, 0x08,
+	0xcd, 0xf4,
+	0x90, 0x33,
+	0x86, 0x00,
+	0x87, 0x0f,
+	0x89, 0x00,
+	0x8b, 0x44,
+	0x8c, 0x66,
+	0x9d, 0xc1,
+	0x8a, 0x10,
+	0xad, 0x40,
+	0xa0, 0x44,
+	0xc0, 0x08,
+	0xc1, 0x10,
+	0xc2, 0x08,
+	0xc3, 0x10,
+	0xc4, 0x08,
+	0xc5, 0xf0,
+	0xc6, 0xff,
+	0xc7, 0x00,
+	0xc8, 0x1a,
+	0xc9, 0x80,
+	0xca, 0x23,
+	0xcb, 0x24,
+	0xcc, 0xf4,
+	0xce, 0x74,
+	0x00, 0x00,
+	0xbd, 0x01,
+	0xb8, 0x00
+};
+
+struct ds3103_state {
+	struct i2c_adapter *i2c;
+	const struct ds3103_config *config;
+	struct dvb_frontend frontend;
+	/* previous uncorrected block counter for DVB-S2 */
+	u16 prevUCBS2;
+};
+
+static int ds3103_writereg(struct ds3103_state *state, int reg, int data)
+{
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg = { .addr = state->config->demod_address,
+		.flags = 0, .buf = buf, .len = 2 };
+	int err;
+
+	dprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);
+
+	err = i2c_transfer(state->i2c, &msg, 1);
+	if (err != 1) {
+		printk(KERN_ERR "%s: writereg error(err == %i, reg == 0x%02x,"
+			 " value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	return 0;
+}
+
+/* I2C write for 8k firmware load */
+static int ds3103_writeFW(struct ds3103_state *state, int reg,
+				const u8 *data, u16 len)
+{
+	int i, ret = -EREMOTEIO;
+	struct i2c_msg msg;
+	u8 *buf;
+
+	buf = kmalloc(33, GFP_KERNEL);
+	if (buf == NULL) {
+		printk(KERN_ERR "Unable to kmalloc\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	*(buf) = reg;
+
+	msg.addr = state->config->demod_address;
+	msg.flags = 0;
+	msg.buf = buf;
+	msg.len = 33;
+   
+	for (i = 0; i < len; i += 32) {
+		memcpy(buf + 1, data + i, 32);
+
+		dprintk("%s: write reg 0x%02x, len = %d\n", __func__, reg, len);
+
+		ret = i2c_transfer(state->i2c, &msg, 1);
+		if (ret != 1) {
+			printk(KERN_ERR "%s: write error(err == %i, "
+				"reg == 0x%02x\n", __func__, ret, reg);
+			ret = -EREMOTEIO;
+		}
+	}
+
+error:
+	kfree(buf);
+
+	return ret;
+}
+
+static int ds3103_readreg(struct ds3103_state *state, u8 reg)
+{
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = state->config->demod_address,
+			.flags = 0,
+			.buf = b0,
+			.len = 1
+		}, {
+			.addr = state->config->demod_address,
+			.flags = I2C_M_RD,
+			.buf = b1,
+			.len = 1
+		}
+	};
+
+	ret = i2c_transfer(state->i2c, msg, 2);
+
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	dprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);
+
+	return b1[0];
+}
+
+static int ds3103_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	
+	if (enable)
+		ds3103_writereg(state, 0x03, 0x12);
+	else
+		ds3103_writereg(state, 0x03, 0x02);
+	
+	return 0;
+}
+static int ds3103_load_firmware(struct dvb_frontend *fe,
+					const struct firmware *fw);
+
+static int ds3103_firmware_ondemand(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	const struct firmware *fw;
+	int ret = 0;
+
+	dprintk("%s()\n", __func__);
+
+	if (ds3103_readreg(state, 0xb2) <= 0)
+		return ret;
+
+	/* global reset, global diseqc reset, global fec reset */
+	ds3103_writereg(state, 0x07, 0xe0);
+	ds3103_writereg(state, 0x07, 0x00);
+
+	/* request the firmware, this will block until someone uploads it */
+	printk(KERN_INFO "%s: Waiting for firmware upload (%s)...\n", __func__,
+				DS3103_DEFAULT_FIRMWARE);
+	ret = request_firmware(&fw, DS3103_DEFAULT_FIRMWARE,
+				state->i2c->dev.parent);
+	printk(KERN_INFO "%s: Waiting for firmware upload(2)...\n", __func__);
+	if (ret) {
+		printk(KERN_ERR "%s: No firmware uploaded (timeout or file not "
+				"found?)\n", __func__);
+		return ret;
+	}
+
+	ret = ds3103_load_firmware(fe, fw);
+	if (ret)
+		printk("%s: Writing firmware to device failed\n", __func__);
+
+	release_firmware(fw);
+
+	dprintk("%s: Firmware upload %s\n", __func__,
+			ret == 0 ? "complete" : "failed");
+
+	return ret;
+}
+
+static int ds3103_load_firmware(struct dvb_frontend *fe,
+					const struct firmware *fw)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+
+	dprintk("%s\n", __func__);
+	dprintk("Firmware is %zu bytes (%02x %02x .. %02x %02x)\n",
+			fw->size,
+			fw->data[0],
+			fw->data[1],
+			fw->data[fw->size - 2],
+			fw->data[fw->size - 1]);
+
+	/* Begin the firmware load process */
+	ds3103_writereg(state, 0xb2, 0x01);
+	/* write the entire firmware */
+	ds3103_writeFW(state, 0xb0, fw->data, fw->size);
+	ds3103_writereg(state, 0xb2, 0x00);
+
+	return 0;
+}
+
+static int ds3103_set_voltage(struct dvb_frontend *fe, fe_sec_voltage_t voltage)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	u8 data;
+
+	dprintk("%s(%d)\n", __func__, voltage);
+
+	data = ds3103_readreg(state, 0xa2);
+	data |= 0x03; /* bit0 V/H, bit1 off/on */
+
+	switch (voltage) {
+	case SEC_VOLTAGE_18:
+		data &= ~0x03;
+		break;
+	case SEC_VOLTAGE_13:
+		data &= ~0x03;
+		data |= 0x01;
+		break;
+	case SEC_VOLTAGE_OFF:
+		break;
+	}
+
+	ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+static int ds3103_read_status(struct dvb_frontend *fe, fe_status_t* status)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	int lock;
+
+	*status = 0;
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		lock = ds3103_readreg(state, 0xd1);
+		if ((lock & 0x07) == 0x07)
+			*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |
+				FE_HAS_VITERBI | FE_HAS_SYNC |
+				FE_HAS_LOCK;
+
+		break;
+	case SYS_DVBS2:
+		lock = ds3103_readreg(state, 0x0d);
+		if ((lock & 0x8f) == 0x8f)
+			*status = FE_HAS_SIGNAL | FE_HAS_CARRIER |
+				FE_HAS_VITERBI | FE_HAS_SYNC |
+				FE_HAS_LOCK;
+
+		break;
+	default:
+		return 1;
+	}
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, *status == 0 ? 0 : 1);
+
+	dprintk("%s: status = 0x%02x\n", __func__, lock);
+
+	return 0;
+}
+
+/* read DS3103 BER value */
+static int ds3103_read_ber(struct dvb_frontend *fe, u32* ber)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 data;
+	u32 ber_reading, lpdc_frames;
+
+	dprintk("%s()\n", __func__);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		/* set the number of bytes checked during
+		BER estimation */
+		ds3103_writereg(state, 0xf9, 0x04);
+		/* read BER estimation status */
+		data = ds3103_readreg(state, 0xf8);
+		/* check if BER estimation is ready */
+		if ((data & 0x10) == 0) {
+			/* this is the number of error bits,
+			to calculate the bit error rate
+			divide to 8388608 */
+			*ber = (ds3103_readreg(state, 0xf7) << 8) |
+				ds3103_readreg(state, 0xf6);
+			/* start counting error bits */
+			/* need to be set twice
+			otherwise it fails sometimes */
+			data |= 0x10;
+			ds3103_writereg(state, 0xf8, data);
+			ds3103_writereg(state, 0xf8, data);
+		} else
+			/* used to indicate that BER estimation
+			is not ready, i.e. BER is unknown */
+			*ber = 0xffffffff;
+		break;
+	case SYS_DVBS2:
+		/* read the number of LPDC decoded frames */
+		lpdc_frames = (ds3103_readreg(state, 0xd7) << 16) |
+				(ds3103_readreg(state, 0xd6) << 8) |
+				ds3103_readreg(state, 0xd5);
+		/* read the number of packets with bad CRC */
+		ber_reading = (ds3103_readreg(state, 0xf8) << 8) |
+				ds3103_readreg(state, 0xf7);
+		if (lpdc_frames > 750) {
+			/* clear LPDC frame counters */
+			ds3103_writereg(state, 0xd1, 0x01);
+			/* clear bad packets counter */
+			ds3103_writereg(state, 0xf9, 0x01);
+			/* enable bad packets counter */
+			ds3103_writereg(state, 0xf9, 0x00);
+			/* enable LPDC frame counters */
+			ds3103_writereg(state, 0xd1, 0x00);
+			*ber = ber_reading;
+		} else
+			/* used to indicate that BER estimation is not ready,
+			i.e. BER is unknown */
+			*ber = 0xffffffff;
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+/* calculate DS3103 snr value in dB */
+static int ds3103_read_snr(struct dvb_frontend *fe, u16 *snr)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 snr_reading, snr_value;
+	u32 dvbs2_signal_reading, dvbs2_noise_reading, tmp;
+	static const u16 dvbs_snr_tab[] = { /* 20 x Table (rounded up) */
+		0x0000, 0x1b13, 0x2aea, 0x3627, 0x3ede, 0x45fe, 0x4c03,
+		0x513a, 0x55d4, 0x59f2, 0x5dab, 0x6111, 0x6431, 0x6717,
+		0x69c9, 0x6c4e, 0x6eac, 0x70e8, 0x7304, 0x7505
+	};
+	static const u16 dvbs2_snr_tab[] = { /* 80 x Table (rounded up) */
+		0x0000, 0x0bc2, 0x12a3, 0x1785, 0x1b4e, 0x1e65, 0x2103,
+		0x2347, 0x2546, 0x2710, 0x28ae, 0x2a28, 0x2b83, 0x2cc5,
+		0x2df1, 0x2f09, 0x3010, 0x3109, 0x31f4, 0x32d2, 0x33a6,
+		0x3470, 0x3531, 0x35ea, 0x369b, 0x3746, 0x37ea, 0x3888,
+		0x3920, 0x39b3, 0x3a42, 0x3acc, 0x3b51, 0x3bd3, 0x3c51,
+		0x3ccb, 0x3d42, 0x3db6, 0x3e27, 0x3e95, 0x3f00, 0x3f68,
+		0x3fcf, 0x4033, 0x4094, 0x40f4, 0x4151, 0x41ac, 0x4206,
+		0x425e, 0x42b4, 0x4308, 0x435b, 0x43ac, 0x43fc, 0x444a,
+		0x4497, 0x44e2, 0x452d, 0x4576, 0x45bd, 0x4604, 0x4649,
+		0x468e, 0x46d1, 0x4713, 0x4755, 0x4795, 0x47d4, 0x4813,
+		0x4851, 0x488d, 0x48c9, 0x4904, 0x493f, 0x4978, 0x49b1,
+		0x49e9, 0x4a20, 0x4a57
+	};
+
+	dprintk("%s()\n", __func__);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		snr_reading = ds3103_readreg(state, 0xff);
+		snr_reading /= 8;
+		if (snr_reading == 0)
+			*snr = 0x0000;
+		else {
+			if (snr_reading > 20)
+				snr_reading = 20;
+			snr_value = dvbs_snr_tab[snr_reading - 1] * 10 / 23026;
+			/* cook the value to be suitable for szap-s2
+			human readable output */
+			*snr = snr_value * 8 * 655;
+		}
+		dprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,
+				snr_reading, *snr);
+		break;
+	case SYS_DVBS2:
+		dvbs2_noise_reading = (ds3103_readreg(state, 0x8c) & 0x3f) +
+				(ds3103_readreg(state, 0x8d) << 4);
+		dvbs2_signal_reading = ds3103_readreg(state, 0x8e);
+		tmp = dvbs2_signal_reading * dvbs2_signal_reading >> 1;
+		if (tmp == 0) {
+			*snr = 0x0000;
+			return 0;
+		}
+		if (dvbs2_noise_reading == 0) {
+			snr_value = 0x0013;
+			/* cook the value to be suitable for szap-s2
+			human readable output */
+			*snr = 0xffff;
+			return 0;
+		}
+		if (tmp > dvbs2_noise_reading) {
+			snr_reading = tmp / dvbs2_noise_reading;
+			if (snr_reading > 80)
+				snr_reading = 80;
+			snr_value = dvbs2_snr_tab[snr_reading - 1] / 1000;
+			/* cook the value to be suitable for szap-s2
+			human readable output */
+			*snr = snr_value * 5 * 655;
+		} else {
+			snr_reading = dvbs2_noise_reading / tmp;
+			if (snr_reading > 80)
+				snr_reading = 80;
+			*snr = -(dvbs2_snr_tab[snr_reading] / 1000);
+		}
+		dprintk("%s: raw / cooked = 0x%02x / 0x%04x\n", __func__,
+				snr_reading, *snr);
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+/* read DS3103 uncorrected blocks */
+static int ds3103_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 data;
+	u16 _ucblocks;
+
+	dprintk("%s()\n", __func__);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS:
+		*ucblocks = (ds3103_readreg(state, 0xf5) << 8) |
+				ds3103_readreg(state, 0xf4);
+		data = ds3103_readreg(state, 0xf8);
+		/* clear packet counters */
+		data &= ~0x20;
+		ds3103_writereg(state, 0xf8, data);
+		/* enable packet counters */
+		data |= 0x20;
+		ds3103_writereg(state, 0xf8, data);
+		break;
+	case SYS_DVBS2:
+		_ucblocks = (ds3103_readreg(state, 0xe2) << 8) |
+				ds3103_readreg(state, 0xe1);
+		if (_ucblocks > state->prevUCBS2)
+			*ucblocks = _ucblocks - state->prevUCBS2;
+		else
+			*ucblocks = state->prevUCBS2 - _ucblocks;
+		state->prevUCBS2 = _ucblocks;
+		break;
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+static int ds3103_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	u8 data;
+
+	dprintk("%s(%d)\n", __func__, tone);
+	if ((tone != SEC_TONE_ON) && (tone != SEC_TONE_OFF)) {
+		printk(KERN_ERR "%s: Invalid, tone=%d\n", __func__, tone);
+		return -EINVAL;
+	}
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	ds3103_writereg(state, 0xa2, data);
+
+	switch (tone) {
+	case SEC_TONE_ON:
+		dprintk("%s: setting tone on\n", __func__);
+		data = ds3103_readreg(state, 0xa1);
+		data &= ~0x43;
+		data |= 0x04;
+		ds3103_writereg(state, 0xa1, data);
+		break;
+	case SEC_TONE_OFF:
+		dprintk("%s: setting tone off\n", __func__);
+		data = ds3103_readreg(state, 0xa2);
+		data |= 0x80;
+		ds3103_writereg(state, 0xa2, data);
+		break;
+	}
+
+	return 0;
+}
+
+static int ds3103_send_diseqc_msg(struct dvb_frontend *fe,
+				struct dvb_diseqc_master_cmd *d)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	int i;
+	u8 data;
+
+	/* Dump DiSEqC message */
+	dprintk("%s(", __func__);
+	for (i = 0 ; i < d->msg_len;) {
+		dprintk("0x%02x", d->msg[i]);
+		if (++i < d->msg_len)
+			dprintk(", ");
+	}
+
+	/* enable DiSEqC message send pin */
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data &= ~0x20;
+	ds3103_writereg(state, 0xa2, data);
+
+	/* DiSEqC message */
+	for (i = 0; i < d->msg_len; i++)
+		ds3103_writereg(state, 0xa3 + i, d->msg[i]);
+
+	data = ds3103_readreg(state, 0xa1);
+	/* clear DiSEqC message length and status,
+	enable DiSEqC message send */
+	data &= ~0xf8;
+	/* set DiSEqC mode, modulation active during 33 pulses,
+	set DiSEqC message length */
+	data |= ((d->msg_len - 1) << 3) | 0x07;
+	ds3103_writereg(state, 0xa1, data);
+
+	/* wait up to 150ms for DiSEqC transmission to complete */
+	for (i = 0; i < 15; i++) {
+		data = ds3103_readreg(state, 0xa1);
+		if ((data & 0x40) == 0)
+			break;
+		msleep(10);
+	}
+
+	/* DiSEqC timeout after 150ms */
+	if (i == 15) {
+		data = ds3103_readreg(state, 0xa1);
+		data &= ~0x80;
+		data |= 0x40;
+		ds3103_writereg(state, 0xa1, data);
+
+		data = ds3103_readreg(state, 0xa2);
+		data &= ~0xc0;
+		data |= 0x80;
+		ds3103_writereg(state, 0xa2, data);
+
+		return 1;
+	}
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data |= 0x80;
+	ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+/* Send DiSEqC burst */
+static int ds3103_diseqc_send_burst(struct dvb_frontend *fe,
+					fe_sec_mini_cmd_t burst)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	int i;
+	u8 data;
+
+	dprintk("%s()\n", __func__);
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data &= ~0x20;
+	ds3103_writereg(state, 0xa2, data);
+
+	/* DiSEqC burst */
+	if (burst == SEC_MINI_A)
+		/* Unmodulated tone burst */
+		ds3103_writereg(state, 0xa1, 0x02);
+	else if (burst == SEC_MINI_B)
+		/* Modulated tone burst */
+		ds3103_writereg(state, 0xa1, 0x01);
+	else
+		return -EINVAL;
+
+	msleep(13);
+	for (i = 0; i < 5; i++) {
+		data = ds3103_readreg(state, 0xa1);
+		if ((data & 0x40) == 0)
+			break;
+		msleep(1);
+	}
+
+	if (i == 5) {
+		data = ds3103_readreg(state, 0xa1);
+		data &= ~0x80;
+		data |= 0x40;
+		ds3103_writereg(state, 0xa1, data);
+
+		data = ds3103_readreg(state, 0xa2);
+		data &= ~0xc0;
+		data |= 0x80;
+		ds3103_writereg(state, 0xa2, data);
+
+		return 1;
+	}
+
+	data = ds3103_readreg(state, 0xa2);
+	data &= ~0xc0;
+	data |= 0x80;
+	ds3103_writereg(state, 0xa2, data);
+
+	return 0;
+}
+
+static void ds3103_release(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, 0);
+
+	dprintk("%s\n", __func__);
+	kfree(state);
+}
+
+static struct dvb_frontend_ops ds3103_ops;
+
+struct dvb_frontend *ds3103_attach(const struct ds3103_config *config,
+				    struct i2c_adapter *i2c)
+{
+	struct ds3103_state *state = NULL;
+	int ret;
+	u8 val_01, val_02, val_b2;
+
+
+	dprintk("%s\n", __func__);
+
+	/* allocate memory for the internal state */
+	state = kzalloc(sizeof(struct ds3103_state), GFP_KERNEL);
+	if (state == NULL) {
+		printk(KERN_ERR "Unable to kmalloc\n");
+		goto error2;
+	}
+
+	state->config = config;
+	state->i2c = i2c;
+	state->prevUCBS2 = 0;
+
+	/* check if the demod is present */
+	ret = ds3103_readreg(state, 0x00) & 0xfe;
+	if (ret != 0xe0) {
+		printk(KERN_ERR "Invalid probe, probably not a DS3x0x\n");
+		goto error3;
+	}
+
+	/* check demod chip ID */
+	val_01 = ds3103_readreg(state, 0x01);
+	val_02 = ds3103_readreg(state, 0x02);
+	val_b2 = ds3103_readreg(state, 0xb2);
+	if((val_02 == 0x00) &&
+			(val_01 == 0xD0) && ((val_b2 & 0xC0) == 0xC0)) {
+		printk("\tChip ID = [DS3103]!\n");
+	} else if((val_02 == 0x00) &&
+			(val_01 == 0xD0) && ((val_b2 & 0xC0) == 0x00)) {
+		printk("\tChip ID = [DS3002B]!\n");
+	} else if ((val_02 == 0x00) && (val_01 == 0xC0)) {
+		printk("\tChip ID = [DS300X]! Not supported by this module\n");
+		goto error3;
+	} else {
+		printk("\tChip ID = unknow!\n");
+		goto error3;
+	}
+
+	printk(KERN_INFO "DS3103 chip version: %d.%d attached.\n", val_02, val_01);
+
+	memcpy(&state->frontend.ops, &ds3103_ops,
+			sizeof(struct dvb_frontend_ops));
+	state->frontend.demodulator_priv = state;
+	return &state->frontend;
+
+error3:
+	kfree(state);
+error2:
+	return NULL;
+}
+EXPORT_SYMBOL(ds3103_attach);
+
+static int ds3103_set_carrier_offset(struct dvb_frontend *fe,
+					s32 carrier_offset_khz,
+					u32 target_mclk)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	s32 tmp;
+
+	tmp = carrier_offset_khz;
+	tmp *= 65536;
+	tmp = (2 * tmp + target_mclk) / (2 * target_mclk);
+
+	if (tmp < 0)
+		tmp += 65536;
+
+	ds3103_writereg(state, 0x5f, tmp >> 8);
+	ds3103_writereg(state, 0x5e, tmp & 0xff);
+
+	return 0;
+}
+static int ds3103_set_ts_div(struct ds3103_state *state, u8 tmp1, u8 tmp2)
+{
+	u8 buf;
+	tmp1 -= 1;
+	tmp2 -= 1;
+
+	tmp1 &= 0x3f;
+	tmp2 &= 0x3f;
+
+	buf = ds3103_readreg(state, 0xfe);
+	buf &= 0xf0;
+	buf |= (tmp1 >> 2) & 0x0f;
+	ds3103_writereg(state, 0xfe, buf);
+
+	buf = (u8)((tmp1 & 0x03) << 6);
+	buf |= tmp2;
+	ds3103_writereg(state, 0xea, buf);
+
+	return 0;
+}
+
+u32 ds3103_get_mclk(struct ds3103_state *state)
+{
+	u32 p_mclk_khz = 96000;
+	u8 tmp1, tmp2;
+
+	tmp1 = ds3103_readreg(state, 0x22);
+	tmp2 = ds3103_readreg(state, 0x24);
+
+	tmp1 >>= 6;
+	tmp1 &= 0x03;
+	tmp2 >>= 6;
+	tmp2 &= 0x03;
+
+	if((tmp1 == 0x00) && (tmp2 == 0x01))
+		p_mclk_khz = 144000;
+	else if ((tmp1 == 0x00) && (tmp2 == 0x03))
+		p_mclk_khz = 72000;
+	else if ((tmp1 == 0x01) && (tmp2 == 0x01))
+		p_mclk_khz = 115200;
+	else if ((tmp1 == 0x02) && (tmp2 == 0x01))
+		p_mclk_khz = 96000;
+	else if ((tmp1 == 0x03) && (tmp2 == 0x00))
+		p_mclk_khz = 192000;
+
+	return p_mclk_khz;
+}
+
+static int ds3103_set_clock_ratio(struct ds3103_state *state, u32 target_mclk)
+{
+	struct dvb_frontend *fe = &state->frontend;
+	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
+	u8	mod_fac, tmp1, tmp2;
+	u32	input_datarate;
+	u32 mclk_khz = target_mclk;
+	u16 divid_ratio = 0;
+	u32 sym_rate_kss = p->symbol_rate / 1000;
+
+	if (p->delivery_system == SYS_DVBS2) {
+		switch(p->modulation) {
+		case PSK_8:
+			mod_fac = 3;
+			break;
+		case APSK_16:
+			mod_fac = 4;
+			break;
+		case APSK_32:
+			mod_fac = 5;
+			break;
+		case QPSK:
+		default:
+			mod_fac = 2;
+			break;
+		}
+
+		switch(p->fec_inner) {
+/*		case FEC_1_4:
+ *			input_datarate = sym_rate_kss * mod_fac / 8 / 4;
+ *			break;
+ *		case FEC_1_3:
+ *			input_datarate = sym_rate_kss * mod_fac / 8 / 3;
+ *			break;
+ */
+		case FEC_2_5:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 8 / 5;
+			break;
+		case FEC_1_2:
+			input_datarate = sym_rate_kss * mod_fac / 8 / 2;
+			break;
+		case FEC_3_5:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 8 / 5;
+			break;
+		case FEC_2_3:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 8 / 3;
+			break;
+		case FEC_3_4:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 8 / 4;
+			break;
+		case FEC_4_5:
+			input_datarate = sym_rate_kss * mod_fac * 4 / 8 / 5;
+			break;
+		case FEC_5_6:
+			input_datarate = sym_rate_kss * mod_fac * 5 / 8 / 6;
+			break;
+		case FEC_8_9:
+			input_datarate = sym_rate_kss * mod_fac * 8 / 8 / 9;
+			break;
+		case FEC_9_10:
+			input_datarate = sym_rate_kss * mod_fac * 9 / 8 / 10;
+			break;
+		default:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 8 / 3;
+			break;
+		}
+
+		/* parallel or CI mode for now */
+		if (input_datarate != 0)
+			divid_ratio = mclk_khz / input_datarate;
+		else
+			divid_ratio = 0xff;
+
+		if (divid_ratio > 128)
+			divid_ratio = 128;
+		
+		if (divid_ratio < 2)
+			divid_ratio = 2;
+		
+		tmp1 = divid_ratio / 2;
+		tmp2 = divid_ratio / 2;
+		
+		if ((divid_ratio % 2) != 0)
+			tmp2 += 1;
+
+	} else { /* for dvb-s */
+		mod_fac = 2;
+
+		switch (p->fec_inner) {
+		case FEC_1_2:
+			input_datarate = sym_rate_kss * mod_fac / 2 / 8;
+			break;
+		case FEC_2_3:
+			input_datarate = sym_rate_kss * mod_fac * 2 / 3 / 8;
+			break;
+		case FEC_3_4:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 4 / 8;
+			break;
+		case FEC_5_6:
+			input_datarate = sym_rate_kss * mod_fac * 5 / 6 / 8;
+			break;
+		case FEC_7_8:
+			input_datarate = sym_rate_kss * mod_fac * 7 / 8 / 8;
+			break;
+		default:
+			input_datarate = sym_rate_kss * mod_fac * 3 / 4 / 8;
+			break;
+		}
+
+		if (input_datarate != 0)
+			divid_ratio = mclk_khz / input_datarate;
+		else
+			divid_ratio = 0xff;
+
+		if (divid_ratio > 128)
+			divid_ratio = 128;
+		
+		if (divid_ratio < 2)
+			divid_ratio = 2;
+
+		tmp1 = divid_ratio / 2;
+		tmp2 = divid_ratio / 2;
+
+		if ((divid_ratio % 2) != 0)
+			tmp2 += 1;
+
+	}
+
+	ds3103_set_ts_div(state, tmp1, tmp2);
+
+	return 0;
+}
+
+static int ds3103_set_frontend(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+
+	int i;
+	fe_status_t status;
+	s32 offset_khz;
+	u32 tuner_freq;
+	u16 value;
+	u32 tmp;
+	u8 tmp1, tmp2;
+	u32 target_mclk = 0;
+
+	dprintk("%s() frec=%d symb=%d", __func__, c->frequency, c->symbol_rate);
+
+	if (state->config->set_ts_params)
+		state->config->set_ts_params(fe, 0);
+
+	if (fe->ops.tuner_ops.set_params)
+		fe->ops.tuner_ops.set_params(fe);
+	
+
+	ds3103_writereg(state, 0xb2, 0x01);
+	ds3103_writereg(state, 0x00, 0x01);
+
+	if (fe->ops.tuner_ops.get_frequency)
+		fe->ops.tuner_ops.get_frequency(fe, &tuner_freq);
+
+	offset_khz = tuner_freq - c->frequency;
+
+	value = ds3103_readreg(state, 0x08);
+
+	switch (c->delivery_system) {
+	case SYS_DVBS2:
+		value |= 0x04;
+		ds3103_writereg(state, 0x08, value);
+		for (i = 0; i < sizeof(ds310x_dvbs2_init_tab); i += 2)
+			ds3103_writereg(state,
+				ds310x_dvbs2_init_tab[i],
+				ds310x_dvbs2_init_tab[i + 1]);
+
+		value = ds3103_readreg(state, 0x4d);
+		value &= ~0x02;
+		ds3103_writereg(state, 0x4d, value);
+		value = ds3103_readreg(state, 0x30);
+		value &= ~0x10;
+		ds3103_writereg(state, 0x30, value);
+		if (c->symbol_rate > 28000000) {
+			target_mclk = 192000;
+		} else if (c->symbol_rate > 18000000) {
+			target_mclk = 144000;
+		} else
+			target_mclk = 96000;
+
+		if (c->symbol_rate <= 5000000) {
+			ds3103_writereg(state, 0xc0, 0x04);
+			ds3103_writereg(state, 0x8a, 0x09);
+			ds3103_writereg(state, 0x8b, 0x22);
+			ds3103_writereg(state, 0x8c, 0x88);
+		}
+
+		break;
+	case SYS_DVBS:
+	default:
+		value &= ~0x04;
+		ds3103_writereg(state, 0x08, value);
+		for (i = 0; i < sizeof(ds310x_dvbs_init_tab); i += 2)
+			ds3103_writereg(state,
+					ds310x_dvbs_init_tab[i],
+					ds310x_dvbs_init_tab[i + 1]);
+		
+		target_mclk = 96000;
+		
+		value = ds3103_readreg(state, 0x4d);
+		value &= ~0x02;
+		ds3103_writereg(state, 0x4d, value);
+		value = ds3103_readreg(state, 0x30);
+		value &= ~0x10;
+		ds3103_writereg(state, 0x30, value);
+		
+		break;
+	}
+
+	ds3103_set_clock_ratio(state, target_mclk);
+
+	tmp1 = ds3103_readreg(state, 0x22);
+	tmp2 = ds3103_readreg(state, 0x24);
+
+	switch (target_mclk) {
+	case 192000:
+		tmp1 |= 0xc0;
+		tmp2 &= 0x3f;
+		break;
+
+	case 144000:
+		tmp1 &= 0x3f;
+		tmp2 &= 0x7f;
+		tmp2 |= 0x40;
+		break;
+
+	case 96000:
+	default:
+		tmp1 &= 0xbf;
+		tmp1 |= 0x80;
+
+		tmp2 &= 0x7f;
+		tmp2 |= 0x40;
+		break;
+	}
+
+	ds3103_writereg(state, 0x22, tmp1);
+	ds3103_writereg(state, 0x24, tmp2);
+
+	ds3103_writereg(state, 0x33, 0x99);
+
+	/* enable 27MHz clock output */
+	value = ds3103_readreg(state, 0x29);
+	value &= 0x80;
+	value &= ~0x10;
+	ds3103_writereg(state, 0x29, value);
+
+	/* enable ac coupling */
+	value = ds3103_readreg(state, 0x25);
+	value |= 0x08;
+	ds3103_writereg(state, 0x25, value);
+
+
+	/* enhance symbol rate performance */
+	if ((c->symbol_rate / 1000) <= 3000) {
+		ds3103_writereg(state, 0xc3, 0x08);
+		ds3103_writereg(state, 0xc8, 0x20);
+		ds3103_writereg(state, 0xc4, 0x08);
+		ds3103_writereg(state, 0xc7, 0x00);
+	} else if((c->symbol_rate / 1000) <= 10000) {
+		ds3103_writereg(state, 0xc3, 0x08);
+		ds3103_writereg(state, 0xc8, 0x10);
+		ds3103_writereg(state, 0xc4, 0x08);
+		ds3103_writereg(state, 0xc7, 0x00);
+	} else {
+		ds3103_writereg(state, 0xc3, 0x08);
+		ds3103_writereg(state, 0xc8, 0x06);
+		ds3103_writereg(state, 0xc4, 0x08);
+		ds3103_writereg(state, 0xc7, 0x00);
+	}
+
+	/* normalized symbol rate rounded to the closest integer */
+	tmp = (((c->symbol_rate / 1000) << 15) + 24000) / 48000;
+
+	ds3103_writereg(state, 0x61, tmp & 0x00ff);
+	ds3103_writereg(state, 0x62, (tmp & 0xff00) >> 8);
+
+	/* co-channel interference cancellation disabled */
+	value = ds3103_readreg(state, 0x56);
+	value &= ~0x01;
+	ds3103_writereg(state, 0x56, value);
+	/* equalizer disabled */
+	value = ds3103_readreg(state, 0x76);
+	value &= ~0x80;
+	ds3103_writereg(state, 0x76, value);
+	/* offset */
+	if ((c->symbol_rate / 1000) < 5000)
+		offset_khz += 3000;
+	ds3103_set_carrier_offset(fe, offset_khz, target_mclk);
+
+	/* ds3000 out of software reset */
+	ds3103_writereg(state, 0x00, 0x00);
+	/* start ds3000 build-in uC */
+	ds3103_writereg(state, 0xb2, 0x00);
+
+
+	for (i = 0; i < 30 ; i++) {
+		ds3103_read_status(fe, &status);
+		if (status && FE_HAS_LOCK)
+			break;
+
+		msleep(10);
+	}
+
+	return 0;
+}
+
+static int ds3103_tune(struct dvb_frontend *fe,
+			bool re_tune,
+			unsigned int mode_flags,
+			unsigned int *delay,
+			fe_status_t *status)
+{
+	if (re_tune) {
+		int ret = ds3103_set_frontend(fe);
+		if (ret)
+			return ret;
+	}
+
+	*delay = HZ / 5;
+
+	return ds3103_read_status(fe, status);
+}
+
+static enum dvbfe_algo ds3103_get_algo(struct dvb_frontend *fe)
+{
+	dprintk("%s()\n", __func__);
+	return DVBFE_ALGO_HW;
+}
+
+/*
+ * Initialize or wake up device
+ *
+ * Power config will reset and load initial firmware if required
+ */
+static int ds3103_initfe(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+	int ret;
+	u8 buf;
+	u8 val_08;
+
+	dprintk("%s()\n", __func__);
+	/* hard reset */
+	buf = ds3103_readreg(state, 0xb2);
+	if (buf == 0x01) {
+		ds3103_writereg(state, 0x00, 0x00);
+		ds3103_writereg(state, 0xb2, 0x00);
+	}
+
+
+	/* global reset */
+	ds3103_writereg(state, 0x07, 0xe0);
+	ds3103_writereg(state, 0x07, 0x00);
+	ds3103_writereg(state, 0x08, 0x01 | ds3103_readreg(state, 0x08));
+	msleep(1);
+
+	/* Load the firmware if required */
+	ret = ds3103_firmware_ondemand(fe);
+	if (ret != 0) {
+		printk(KERN_ERR "%s: Unable initialize firmware\n", __func__);
+		return ret;
+	}
+	/* ts out mode */
+	val_08 = ds3103_readreg(state, 0x08);
+	buf = ds3103_readreg(state, 0x27);
+	buf &= ~0x01;
+	ds3103_writereg(state, 0x27, buf);
+	/* for dvb-s */
+	buf = val_08 & (~0x04) ;
+	ds3103_writereg(state, 0x08, buf);
+	ds3103_set_ts_div(state, 6, 6);
+
+	/* for dvb-s2 */
+	buf = val_08 | 0x04 ;
+	ds3103_writereg(state, 0x08, buf);
+	ds3103_set_ts_div(state, 8, 9);
+	buf = ds3103_readreg(state, 0xfd);
+	buf |= 0x01;
+	buf &= ~0x04;
+
+	buf &= ~0xba;
+	if (state->config->ci_mode)
+		buf |= 0x40;
+	else
+		buf &= ~0x40;
+
+	ds3103_writereg(state, 0xfd, buf);
+	ds3103_writereg(state, 0x08, val_08);
+	buf = ds3103_readreg(state, 0x27);
+	buf |= 0x11;
+	ds3103_writereg(state, 0x27, buf);
+	buf = ds3103_readreg(state, 0x4d);
+	buf &= ~0x02;
+	ds3103_writereg(state, 0x4d, buf);
+	buf = ds3103_readreg(state, 0x30);
+	buf &= ~0x10;
+	ds3103_writereg(state, 0x30, buf);
+
+	return 0;
+}
+
+/* Put device to sleep */
+static int ds3103_sleep(struct dvb_frontend *fe)
+{
+	struct ds3103_state *state = fe->demodulator_priv;
+
+	if (state->config->set_lock_led)
+		state->config->set_lock_led(fe, 0);
+
+	dprintk("%s()\n", __func__);
+	return 0;
+}
+
+static struct dvb_frontend_ops ds3103_ops = {
+	.delsys = { SYS_DVBS, SYS_DVBS2 },
+	.info = {
+		.name = "Montage Technology DS3103/TS2022",
+		.frequency_min = 950000,
+		.frequency_max = 2150000,
+		.frequency_stepsize = 1011, /* kHz for QPSK frontends */
+		.frequency_tolerance = 5000,
+		.symbol_rate_min = 1000000,
+		.symbol_rate_max = 45000000,
+		.caps = FE_CAN_INVERSION_AUTO |
+			FE_CAN_FEC_1_2 | FE_CAN_FEC_2_3 | FE_CAN_FEC_3_4 |
+			FE_CAN_FEC_4_5 | FE_CAN_FEC_5_6 | FE_CAN_FEC_6_7 |
+			FE_CAN_FEC_7_8 | FE_CAN_FEC_AUTO |
+			FE_CAN_2G_MODULATION |
+			FE_CAN_QPSK | FE_CAN_RECOVER
+	},
+
+	.release = ds3103_release,
+
+	.init = ds3103_initfe,
+	.sleep = ds3103_sleep,
+	.read_status = ds3103_read_status,
+	.read_ber = ds3103_read_ber,
+	.i2c_gate_ctrl = ds3103_i2c_gate_ctrl,
+	.read_snr = ds3103_read_snr,
+	.read_ucblocks = ds3103_read_ucblocks,
+	.set_voltage = ds3103_set_voltage,
+	.set_tone = ds3103_set_tone,
+	.diseqc_send_master_cmd = ds3103_send_diseqc_msg,
+	.diseqc_send_burst = ds3103_diseqc_send_burst,
+	.get_frontend_algo = ds3103_get_algo,
+
+	.set_frontend = ds3103_set_frontend,
+	.tune = ds3103_tune,
+};
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Activates frontend debugging (default:0)");
+
+MODULE_DESCRIPTION("DVB Frontend module for Montage Technology "
+			"DS3103 hardware");
+MODULE_AUTHOR("Tomazzo Muzumici");
+MODULE_LICENSE("GPL");
+MODULE_FIRMWARE(DS3103_DEFAULT_FIRMWARE);
diff -Naur a/drivers/media/dvb-frontends/ds3103.h b/drivers/media/dvb-frontends/ds3103.h
--- a/drivers/media/dvb-frontends/ds3103.h	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/media/dvb-frontends/ds3103.h	2014-03-31 21:20:47.000000000 -0700
@@ -0,0 +1,47 @@
+/*
+    Montage Technology DS3103 - DVBS/S2 Demodulator driver
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef DS3103_H
+#define DS3103_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+struct ds3103_config {
+	/* the demodulator's i2c address */
+	u8 demod_address;
+	u8 ci_mode;
+	/* Set device param to start dma */
+	int (*set_ts_params)(struct dvb_frontend *fe, int is_punctured);
+	/* Hook for Lock LED */
+	void (*set_lock_led)(struct dvb_frontend *fe, int offon);
+};
+
+#if IS_ENABLED(CONFIG_DVB_DS3103)
+extern struct dvb_frontend *ds3103_attach(const struct ds3103_config *config,
+					struct i2c_adapter *i2c);
+#else
+static inline
+struct dvb_frontend *ds3103_attach(const struct ds3103_config *config,
+					struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_DS3103 */
+#endif /* DS3103_H */
diff -Naur a/drivers/media/dvb-frontends/Kconfig b/drivers/media/dvb-frontends/Kconfig
--- a/drivers/media/dvb-frontends/Kconfig	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/media/dvb-frontends/Kconfig	2014-03-31 21:20:48.000000000 -0700
@@ -235,6 +235,20 @@
 	help
 	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
 
+config DVB_TS2022
+	tristate "Montage Tehnology TS2022 based tuners"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-S/S2 silicon tuner. Say Y when you want to support this tuner.
+
+config DVB_DS3103
+	tristate "Montage Tehnology DS3103 based"
+	depends on DVB_CORE && I2C
+	default m if !MEDIA_SUBDRV_AUTOSELECT
+	help
+	  A DVB-S/S2 tuner module. Say Y when you want to support this frontend.
+
 config DVB_MB86A16
 	tristate "Fujitsu MB86A16 based"
 	depends on DVB_CORE && I2C
diff -Naur a/drivers/media/dvb-frontends/Makefile b/drivers/media/dvb-frontends/Makefile
--- a/drivers/media/dvb-frontends/Makefile	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/media/dvb-frontends/Makefile	2014-03-31 21:20:48.000000000 -0700
@@ -105,4 +105,6 @@
 obj-$(CONFIG_DVB_RTL2832) += rtl2832.o
 obj-$(CONFIG_DVB_M88RS2000) += m88rs2000.o
 obj-$(CONFIG_DVB_AF9033) += af9033.o
+obj-$(CONFIG_DVB_DS3103) += ds3103.o
+obj-$(CONFIG_DVB_TS2022) += ts2022.o
 
diff -Naur a/drivers/media/dvb-frontends/ts2022.c b/drivers/media/dvb-frontends/ts2022.c
--- a/drivers/media/dvb-frontends/ts2022.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/media/dvb-frontends/ts2022.c	2014-03-31 21:20:48.000000000 -0700
@@ -0,0 +1,452 @@
+  /*
+     Driver for Montage ts2022 DVBS/S2 Silicon tuner
+
+     Copyright (C) 2012 Tomazzo Muzumici
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+  */
+
+#include "dvb_frontend.h"
+#include "ts2022.h"
+
+static int debug;
+#define dprintk(args...) \
+	do { \
+		if (debug) \
+			printk(KERN_DEBUG "ts2022: " args); \
+	} while (0)
+
+#define TS2022_XTAL_FREQ   27000 /* in kHz */
+
+struct ts2022_priv {
+	/* i2c details */
+	int i2c_address;
+	struct i2c_adapter *i2c;
+	u32 frequency;
+};
+
+static int ts2022_release(struct dvb_frontend *fe)
+{
+	kfree(fe->tuner_priv);
+	fe->tuner_priv = NULL;
+	return 0;
+}
+
+static int ts2022_writereg(struct dvb_frontend *fe, int reg, int data)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	u8 buf[] = { reg, data };
+	struct i2c_msg msg[] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.buf = buf,
+			.len = 2
+		}
+	};
+	int err;
+
+	dprintk("%s: write reg 0x%02x, value 0x%02x\n", __func__, reg, data);
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	err = i2c_transfer(priv->i2c, msg, 1);
+	if (err != 1) {
+		printk("%s: writereg error(err == %i, reg == 0x%02x,"
+		" value == 0x%02x)\n", __func__, err, reg, data);
+		return -EREMOTEIO;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return 0;
+}
+
+static int ts2022_readreg(struct dvb_frontend *fe, u8 reg)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	int ret;
+	u8 b0[] = { reg };
+	u8 b1[] = { 0 };
+	struct i2c_msg msg[] = {
+		{
+			.addr = priv->i2c_address,
+			.flags = 0,
+			.buf = b0,
+			.len = 1
+		}, {
+			.addr = priv->i2c_address,
+			.flags = I2C_M_RD,
+			.buf = b1,
+			.len = 1
+		}
+	};
+	
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = i2c_transfer(priv->i2c, msg, 2);
+	
+	if (ret != 2) {
+		printk(KERN_ERR "%s: reg=0x%x(error=%d)\n", __func__, reg, ret);
+		return ret;
+	}
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	dprintk("%s: read reg 0x%02x, value 0x%02x\n", __func__, reg, b1[0]);
+	
+	return b1[0];
+}
+
+static int ts2022_sleep(struct dvb_frontend *fe)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	int ret;
+	u8 buf[] = { 10, 0 };
+	struct i2c_msg msg = {
+		.addr = priv->i2c_address,
+		.flags = 0,
+		.buf = buf,
+		.len = 2
+	};
+
+	dprintk("%s:\n", __func__);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1);
+
+	ret = i2c_transfer(priv->i2c, &msg, 1);
+	if (ret != 1)
+		dprintk("%s: i2c error\n", __func__);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0);
+
+	return (ret == 1) ? 0 : ret;
+}
+
+static int ts2022_set_params(struct dvb_frontend *fe)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	struct dtv_frontend_properties *c = &fe->dtv_property_cache;
+	u8 mlpf, mlpf_new, mlpf_max, mlpf_min, nlpf, div4;
+	u16 value, ndiv;
+	u32 f3db;
+
+	dprintk("%s:\n", __func__);
+
+	ts2022_writereg(fe, 0x10, 0x0b);
+	ts2022_writereg(fe, 0x11, 0x40);
+	div4 = 0;
+	if (c->frequency < 1103000) {
+		ts2022_writereg(fe, 0x10, 0x1b);
+		div4 = 1;
+		ndiv = (c->frequency * (6 + 8) * 4)/TS2022_XTAL_FREQ ;
+	} else
+		ndiv = (c->frequency * (6 + 8) * 2)/TS2022_XTAL_FREQ ;
+
+	ndiv = ndiv + ndiv %2 ;
+	if (ndiv < 4095)
+		value = ndiv - 1024;
+	else if (ndiv < 6143 )
+		value = ndiv + 1024;
+	else
+		value = ndiv + 3072;
+
+	ts2022_writereg(fe, 0x01, (value & 0x3f00) >> 8);
+	ts2022_writereg(fe, 0x02, value & 0x00ff);
+	ts2022_writereg(fe, 0x03, 0x06);
+	ts2022_writereg(fe, 0x51, 0x0f);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x10);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	value =  ts2022_readreg(fe, 0x14);
+	value &=0x7f;
+	if (value < 64 ) {
+		value =  ts2022_readreg(fe, 0x10);
+		value |= 0x80;
+		ts2022_writereg(fe, 0x10, value);
+		ts2022_writereg(fe, 0x11, 0x6f);
+
+		ts2022_writereg(fe, 0x51, 0x0f);
+		ts2022_writereg(fe, 0x51, 0x1f);
+		ts2022_writereg(fe, 0x50, 0x10);
+		ts2022_writereg(fe, 0x50, 0x00);
+	}
+	msleep(5);
+	value =  ts2022_readreg(fe, 0x14);
+	value &=0x1f;
+	if (value > 19) {
+		value =  ts2022_readreg(fe, 0x10);
+		value &= 0x1d;
+		ts2022_writereg(fe, 0x10, value);
+	}
+	/*set the RF gain*/
+	ts2022_writereg(fe, 0x60, 0x79);
+
+	ts2022_writereg(fe, 0x51, 0x17);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x08);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	ts2022_writereg(fe, 0x25, 0x00);
+	ts2022_writereg(fe, 0x27, 0x70);
+	ts2022_writereg(fe, 0x41, 0x09);
+
+	ts2022_writereg(fe, 0x08, 0x0b);
+	ts2022_writereg(fe, 0x04, 0x2e);
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	f3db = ((c->symbol_rate / 1000) * 135) / 200 + 2000;
+	if ((c->symbol_rate / 1000) < 5000)
+		f3db += 3000;
+	if (f3db < 7000)
+		f3db = 7000;
+	if (f3db > 40000)
+		f3db = 40000;
+
+	value = ts2022_readreg(fe, 0x26);
+	value &= 0x3f ;
+
+	ts2022_writereg(fe, 0x41, 0x0d);
+
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+	value = (value + (ts2022_readreg(fe, 0x26) & 0x3f)) / 2;
+	mlpf = 0x2e * 207 / ((value << 1) + 151);
+	mlpf_max = mlpf * 135 / 100;
+	mlpf_min = mlpf * 78 / 100;
+	if (mlpf_max > 63)
+		mlpf_max = 63;
+
+
+		value = 3200;
+	nlpf = ((mlpf * f3db * 1000) + (value * TS2022_XTAL_FREQ / 2))
+			/ (value * TS2022_XTAL_FREQ);
+
+	if (nlpf > 23)
+		nlpf = 23;
+	if (nlpf < 1)
+		nlpf = 1;
+
+	/* rounded to the closest integer */
+	mlpf_new = ((TS2022_XTAL_FREQ * nlpf * value) +
+			(1000 * f3db / 2)) / (1000 * f3db);
+
+	if (mlpf_new < mlpf_min) {
+		nlpf++;
+		mlpf_new = ((TS2022_XTAL_FREQ * nlpf * value) +
+				(1000 * f3db / 2)) / (1000 * f3db);
+	}
+
+	if (mlpf_new > mlpf_max)
+		mlpf_new = mlpf_max;
+
+	ts2022_writereg(fe, 0x04, mlpf_new);
+	ts2022_writereg(fe, 0x06, nlpf);
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+
+	value = ts2022_readreg(fe, 0x26);
+	value &= 0x3f;
+	ts2022_writereg(fe, 0x41, 0x09);
+
+	ts2022_writereg(fe, 0x51, 0x1b);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x04);
+	ts2022_writereg(fe, 0x50, 0x00);
+	msleep(5);
+	value = (value + (ts2022_readreg(fe, 0x26)&0x3f))/2;
+
+	value |= 0x80;
+	ts2022_writereg(fe, 0x25, value);
+	ts2022_writereg(fe, 0x27, 0x30);
+	ts2022_writereg(fe, 0x08, 0x09);
+	ts2022_writereg(fe, 0x51, 0x1e);
+	ts2022_writereg(fe, 0x51, 0x1f);
+	ts2022_writereg(fe, 0x50, 0x01);
+	ts2022_writereg(fe, 0x50, 0x00);
+
+	msleep(60);
+
+	priv->frequency = (u32)(ndiv * TS2022_XTAL_FREQ / (6 + 8) / (div4 + 1) / 2);
+
+	printk("%s: offset %dkhz\n", __func__, priv->frequency - c->frequency);
+	printk("%s:  %dkhz  %dkhz\n", __func__, c->frequency, priv->frequency);
+
+	return 0;
+}
+
+static int ts2022_get_frequency(struct dvb_frontend *fe, u32 *frequency)
+{
+	struct ts2022_priv *priv = fe->tuner_priv;
+	*frequency = priv->frequency;
+	return 0;
+}
+
+static int ts2022_init(struct dvb_frontend *fe)
+{
+	ts2022_writereg(fe, 0x62, 0xec);
+	ts2022_writereg(fe, 0x42, 0x6c);
+	
+	ts2022_writereg(fe, 0x7d, 0x9d);
+	ts2022_writereg(fe, 0x7c, 0x9a);
+	ts2022_writereg(fe, 0x7a, 0x76);
+	
+	ts2022_writereg(fe, 0x3b, 0x01);
+	ts2022_writereg(fe, 0x63, 0x88);
+	
+	ts2022_writereg(fe, 0x61, 0x85);
+	ts2022_writereg(fe, 0x22, 0x30);
+	ts2022_writereg(fe, 0x30, 0x40);
+	ts2022_writereg(fe, 0x20, 0x23);
+	ts2022_writereg(fe, 0x24, 0x02);
+	ts2022_writereg(fe, 0x12, 0xa0);
+
+	return 0;
+}
+
+static int ts2022_read_signal_strength(struct dvb_frontend *fe,
+				       u16 *signal_strength)
+{
+	int sig_reading = 0; 
+	u8 rfgain, bbgain, nngain;
+	u8 rfagc;
+	u32 gain = 0;
+	dprintk("%s()\n", __func__);
+	
+	rfgain = ts2022_readreg(fe, 0x3d) & 0x1f;
+	bbgain = ts2022_readreg(fe, 0x21) & 0x1f;
+	rfagc = ts2022_readreg(fe, 0x3f);
+	sig_reading = rfagc * 16 -670;
+	if (sig_reading<0)
+		sig_reading =0;
+	nngain =ts2022_readreg(fe, 0x66);
+	nngain = (nngain >> 3) & 0x07;
+	
+	if (rfgain < 0)
+		rfgain = 0;
+	if (rfgain > 15)
+		rfgain = 15;
+	if (bbgain < 2)
+		bbgain = 2;
+	if (bbgain > 16)
+		bbgain = 16;
+	if (nngain < 0)
+		nngain = 0;
+	if (nngain > 6)
+		nngain = 6;
+	
+	if (sig_reading < 600)
+		sig_reading = 600;
+	if (sig_reading > 1600)
+		sig_reading = 1600;
+	
+	gain = (u16) rfgain * 265 + (u16) bbgain * 338 + (u16) nngain * 285 + sig_reading * 176 / 100 - 3000;
+	
+	
+	*signal_strength = gain*100;
+	
+	dprintk("%s: raw / cooked = 0x%04x / 0x%04x\n", __func__,
+		sig_reading, *signal_strength);
+	
+	return 0;
+}
+
+static struct dvb_tuner_ops ts2022_tuner_ops = {
+	.info = {
+		.name = "TS2022",
+		.frequency_min = 950000,
+		.frequency_max = 2150000
+	},
+	.init = ts2022_init,
+	.release = ts2022_release,
+	.sleep = ts2022_sleep,
+	.set_params = ts2022_set_params,
+	.get_frequency = ts2022_get_frequency,
+	.get_rf_strength = ts2022_read_signal_strength,
+};
+
+struct dvb_frontend *ts2022_attach(struct dvb_frontend *fe, int addr,
+						struct i2c_adapter *i2c)
+{
+	struct ts2022_priv *priv = NULL;
+	u8 buf;
+
+	dprintk("%s:\n", __func__);
+
+	priv = kzalloc(sizeof(struct ts2022_priv), GFP_KERNEL);
+	if (priv == NULL)
+		return NULL;
+
+	priv->i2c_address = addr;
+	priv->i2c = i2c;
+	fe->tuner_priv = priv;
+
+	/* Wake Up the tuner */
+	buf = ts2022_readreg(fe, 0x00);
+	buf &= 0x03;
+	
+	if (buf == 0x00) {
+		ts2022_writereg(fe, 0x00, 0x01);
+		msleep(2);
+	}
+
+	ts2022_writereg(fe, 0x00, 0x03);
+	msleep(2);
+	
+	/* Check the tuner version */
+	buf = ts2022_readreg(fe, 0x00);
+	if ((buf == 0xc3)|| (buf == 0x83))
+		dprintk(KERN_INFO "%s: Find tuner TS2022!\n", __func__);
+	else {
+		dprintk(KERN_ERR "%s: Read tuner reg[0] = %d\n", __func__, buf);
+		kfree(priv);
+		return NULL;
+	}
+
+	memcpy(&fe->ops.tuner_ops, &ts2022_tuner_ops,
+				sizeof(struct dvb_tuner_ops));
+	fe->ops.read_signal_strength = fe->ops.tuner_ops.get_rf_strength;
+
+	return fe;
+}
+EXPORT_SYMBOL(ts2022_attach);
+
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Turn on/off frontend debugging (default:off).");
+
+MODULE_DESCRIPTION("DVB ts2022 driver");
+MODULE_AUTHOR("Tomazzo Muzumici");
+MODULE_LICENSE("GPL");
diff -Naur a/drivers/media/dvb-frontends/ts2022.h b/drivers/media/dvb-frontends/ts2022.h
--- a/drivers/media/dvb-frontends/ts2022.h	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/media/dvb-frontends/ts2022.h	2014-03-31 21:20:48.000000000 -0700
@@ -0,0 +1,50 @@
+  /*
+     Driver for Montage TS2022 DVBS/S2 Silicon tuner
+
+     Copyright (C) 2012 Tomazzo Muzumici
+
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+
+     GNU General Public License for more details.
+
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+  */
+
+#ifndef TS2022_H
+#define TS2022_H
+
+#include <linux/kconfig.h>
+#include <linux/dvb/frontend.h>
+
+/**
+ * Attach a ts2022 tuner to the supplied frontend structure.
+ *
+ * @param fe Frontend to attach to.
+ * @param addr i2c address of the tuner.
+ * @param i2c i2c adapter to use.
+ * @return FE pointer on success, NULL on failure.
+ */
+#if IS_ENABLED(CONFIG_DVB_TS2022)
+extern struct dvb_frontend *ts2022_attach(struct dvb_frontend *fe, int addr,
+					   struct i2c_adapter *i2c);
+#else
+static inline struct dvb_frontend *ts2022_attach(struct dvb_frontend *fe,
+						  int addr,
+						  struct i2c_adapter *i2c)
+{
+	printk(KERN_WARNING "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif /* CONFIG_DVB_TS2022 */
+
+#endif /* TS2022_H */
diff -Naur a/drivers/media/rc/keymaps/Makefile b/drivers/media/rc/keymaps/Makefile
--- a/drivers/media/rc/keymaps/Makefile	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/media/rc/keymaps/Makefile	2014-04-19 00:27:19.000000000 -0700
@@ -93,6 +93,7 @@
 			rc-total-media-in-hand-02.o \
 			rc-trekstor.o \
 			rc-tt-1500.o \
+			rc-tt-4600.o \
 			rc-twinhan1027.o \
 			rc-videomate-m1f.o \
 			rc-videomate-s350.o \
diff -Naur a/drivers/media/rc/keymaps/rc-tt-4600.c b/drivers/media/rc/keymaps/rc-tt-4600.c
--- a/drivers/media/rc/keymaps/rc-tt-4600.c	1969-12-31 16:00:00.000000000 -0800
+++ b/drivers/media/rc/keymaps/rc-tt-4600.c	2014-04-19 00:27:19.000000000 -0700
@@ -0,0 +1,79 @@
+/* rc-tt_4600.h - Keytable for Geniatech based TT4600 Remote Controller
+ * derived from drivers/media/rc/keymaps/rc-su3000.c
+ * Copyright (c) 2013 by Evgeny Plehov <Evgeny Plehov@ukr.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <media/rc-map.h>
+#include <linux/module.h>
+
+static struct rc_map_table tt_4600[] = {
+       { 0x41, KEY_POWER },
+       { 0x42, KEY_SHUFFLE },
+       { 0x43, KEY_1 },
+       { 0x44, KEY_2 },
+       { 0x45, KEY_3 },
+       { 0x46, KEY_4 },
+       { 0x47, KEY_5 },
+       { 0x48, KEY_6 },
+       { 0x49, KEY_7 },
+       { 0x4a, KEY_8 },
+       { 0x4b, KEY_9 },
+       { 0x4c, KEY_0 },
+       { 0x4d, KEY_UP },
+       { 0x4e, KEY_LEFT },
+       { 0x4f, KEY_OK },
+       { 0x50, KEY_RIGHT },
+       { 0x51, KEY_DOWN },
+       { 0x52, KEY_INFO },
+       { 0x53, KEY_EXIT },
+       { 0x54, KEY_RED },
+       { 0x55, KEY_GREEN },
+       { 0x56, KEY_YELLOW },
+       { 0x57, KEY_BLUE },
+       { 0x58, KEY_MUTE },
+       { 0x59, KEY_TEXT },
+       { 0x5a, KEY_MODE },
+       { 0x61, KEY_OPTION },
+       { 0x62, KEY_EPG },
+       { 0x63, KEY_CHANNELUP },
+       { 0x64, KEY_CHANNELDOWN },
+       { 0x65, KEY_VOLUMEUP },
+       { 0x66, KEY_VOLUMEDOWN },
+       { 0x67, KEY_SETUP },
+       { 0x7a, KEY_RECORD },
+       { 0x7b, KEY_PLAY },
+       { 0x7c, KEY_STOP },
+       { 0x7d, KEY_REWIND },
+       { 0x7e, KEY_PAUSE },
+       { 0x7f, KEY_FORWARD },
+};
+
+static struct rc_map_list tt_4600_map = {
+	.map = {
+		.scan    = tt_4600,
+		.size    = ARRAY_SIZE(tt_4600),
+		.rc_type = RC_TYPE_UNKNOWN,     /* Legacy IR type */
+		.name    = RC_MAP_TT_4600,
+	}
+};
+
+static int __init init_rc_map_tt_4600(void)
+{
+	return rc_map_register(&tt_4600_map);
+}
+
+static void __exit exit_rc_map_tt_4600(void)
+{
+	rc_map_unregister(&tt_4600_map);
+}
+
+module_init(init_rc_map_tt_4600)
+module_exit(exit_rc_map_tt_4600)
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Evgeny Plehov <Evgeny Plehov@ukr.net>");
diff -Naur a/drivers/media/usb/dvb-usb/dw2102.c b/drivers/media/usb/dvb-usb/dw2102.c
--- a/drivers/media/usb/dvb-usb/dw2102.c	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/media/usb/dvb-usb/dw2102.c	2014-04-19 00:27:10.000000000 -0700
@@ -23,7 +23,9 @@
 #include "mt312.h"
 #include "zl10039.h"
 #include "ts2020.h"
+#include "ts2022.h"
 #include "ds3000.h"
+#include "ds3103.h"
 #include "stv0900.h"
 #include "stv6110.h"
 #include "stb6100.h"
@@ -87,6 +89,18 @@
 #define USB_PID_GOTVIEW_SAT_HD 0x5456
 #endif
 
+#ifndef USB_PID_TEVII_S662
+#define USB_PID_TEVII_S662 0xd662
+#endif
+
+#ifndef USB_PID_TEVII_S482_1
+#define USB_PID_TEVII_S482_1 0xd483
+#endif
+
+#ifndef USB_PID_TEVII_S482_2
+#define USB_PID_TEVII_S482_2 0xd484
+#endif
+
 #define DW210X_READ_MSG 0
 #define DW210X_WRITE_MSG 1
 
@@ -1116,6 +1130,12 @@
 	.gate = TDA18271_GATE_DIGITAL,
 };
 
+static struct ds3103_config su3000_ds3103_config = {
+	.demod_address = 0x68,
+	.ci_mode = 0,
+	.set_lock_led = dw210x_led_ctrl,
+};
+
 static u8 m88rs2000_inittab[] = {
 	DEMOD_WRITE, 0x9a, 0x30,
 	DEMOD_WRITE, 0x00, 0x01,
@@ -1342,6 +1362,7 @@
 	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
 
+	/* power on su3000 */
 	obuf[0] = 0xe;
 	obuf[1] = 0x02;
 	obuf[2] = 1;
@@ -1357,6 +1378,7 @@
 	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
 		err("command 0x0e transfer failed.");
 
+	msleep(20);
 	obuf[0] = 0xe;
 	obuf[1] = 0x83;
 	obuf[2] = 1;
@@ -1370,18 +1392,27 @@
 		err("command 0x51 transfer failed.");
 
 	d->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,
-					&d->dev->i2c_adap);
-	if (d->fe_adap[0].fe == NULL)
-		return -EIO;
-
-	if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
-				&dw2104_ts2020_config,
-				&d->dev->i2c_adap)) {
+				&d->dev->i2c_adap);
+	if (d->fe_adap[0].fe != NULL) {
+		if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
+			&dw2104_ts2020_config,
+			&d->dev->i2c_adap)) {
 		info("Attached DS3000/TS2020!\n");
 		return 0;
+		}
+	}
+
+	d->fe_adap[0].fe = dvb_attach(ds3103_attach, &su3000_ds3103_config,
+				&d->dev->i2c_adap);
+	if (d->fe_adap[0].fe != NULL) {
+		if (dvb_attach(ts2022_attach, d->fe_adap[0].fe, 0x60,
+			&d->dev->i2c_adap)) {
+		info("Attached at addr. 0x60 DS3103/TS2022!\n");
+		return 0;
+		}
 	}
 
-	info("Failed to attach DS3000/TS2020!\n");
+	info("Failed to attach DS3X0X/TS202X!\n");
 	return -EIO;
 }
 
@@ -1550,8 +1581,17 @@
 	TEVII_S421,
 	TEVII_S632,
 	TERRATEC_CINERGY_S2_R2,
+	TT_S2_4600,
 	GOTVIEW_SAT_HD,
 	GENIATECH_T220,
+	VP2000,
+	TEVII_S662,
+	TEVII_S482_1,
+	TEVII_S482_2,
+	TERRATEC_S2_BOX,
+	TERRATEC_DUAL_1,
+	TERRATEC_DUAL_2,
+
 };
 
 static struct usb_device_id dw2102_table[] = {
@@ -1573,8 +1613,16 @@
 	[TEVII_S421] = {USB_DEVICE(0x9022, USB_PID_TEVII_S421)},
 	[TEVII_S632] = {USB_DEVICE(0x9022, USB_PID_TEVII_S632)},
 	[TERRATEC_CINERGY_S2_R2] = {USB_DEVICE(USB_VID_TERRATEC, 0x00b0)},
+	[TT_S2_4600] = {USB_DEVICE(0x0b48, 0x3011)},
 	[GOTVIEW_SAT_HD] = {USB_DEVICE(0x1FE1, USB_PID_GOTVIEW_SAT_HD)},
+	[VP2000] = {USB_DEVICE(0x9022, 0x2000)},
+	[TEVII_S662] = {USB_DEVICE(0x9022, USB_PID_TEVII_S662)},
+	[TEVII_S482_1] = {USB_DEVICE(0x9022, USB_PID_TEVII_S482_1)},
+	[TEVII_S482_2] = {USB_DEVICE(0x9022, USB_PID_TEVII_S482_2)},
 	[GENIATECH_T220] = {USB_DEVICE(0x1f4d, 0xD220)},
+	[TERRATEC_S2_BOX] = {USB_DEVICE(USB_VID_TERRATEC, 0x0105)},
+	[TERRATEC_DUAL_1] = {USB_DEVICE(0x153B,0x1181)},
+	[TERRATEC_DUAL_2] = {USB_DEVICE(0x153B,0x1182)},
 	{ }
 };
 
@@ -2052,6 +2100,57 @@
 	}
 };
 
+
+static struct dvb_usb_device_description d2000 = {
+        "VisionPlus VP2000 USB",
+        {&dw2102_table[VP2000], NULL},
+        {NULL},
+};
+
+struct dvb_usb_device_properties *s662;
+static struct dvb_usb_device_description d662 = {
+	"TeVii S662",
+	{&dw2102_table[TEVII_S662], NULL},
+	{NULL},
+};
+
+static struct dvb_usb_device_description d482_1 = {
+        "TeVii S482.1 USB",
+        {&dw2102_table[TEVII_S482_1], NULL},
+        {NULL},
+};
+
+static struct dvb_usb_device_description d482_2 = {
+        "TeVii S482.2 USB",
+        {&dw2102_table[TEVII_S482_2], NULL},
+        {NULL},
+};
+
+static struct dvb_usb_device_description d662t = {
+        "Terratec Cinergy S2 USB BOX",
+        {&dw2102_table[TERRATEC_S2_BOX], NULL},
+        {NULL},
+};
+
+static struct dvb_usb_device_description d482t_1 = {
+        "Terratec Cinergy S2 Dual 1 USB",
+        {&dw2102_table[TERRATEC_DUAL_1], NULL},
+        {NULL},
+};
+
+static struct dvb_usb_device_description d482t_2 = {
+        "Terratec Cinergy S2 Dual 2 USB",
+        {&dw2102_table[TERRATEC_DUAL_2], NULL},
+        {NULL},
+};
+
+struct dvb_usb_device_properties *tt4600;
+static struct dvb_usb_device_description d4600 = {
+        "TT Connect S2 4600",
+        {&dw2102_table[TT_S2_4600], NULL},
+        {NULL},
+};
+
 static int dw2102_probe(struct usb_interface *intf,
 		const struct usb_device_id *id)
 {
@@ -2102,11 +2201,50 @@
 		kfree(p7500);
 		return -ENOMEM;
 	}
-	s421->num_device_descs = 2;
+	s421->num_device_descs = 3;
 	s421->devices[0] = d421;
 	s421->devices[1] = d632;
+	s421->devices[2] = d2000;
 	s421->adapter->fe[0].frontend_attach = m88rs2000_frontend_attach;
 
+        s662 = kmemdup(&su3000_properties,
+                       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
+        if (!s662) {
+                kfree(s421);
+                kfree(p1100);
+                kfree(s660);
+                kfree(p7500);
+                return -ENOMEM;
+        }
+        s662->num_device_descs = 6;
+        s662->devices[0] = d662;
+        s662->devices[1] = d482_1;
+        s662->devices[2] = d482_2;
+        s662->devices[3] = d662t;
+        s662->devices[4] = d482t_1;
+        s662->devices[5] = d482t_2;
+        s662->rc.core.rc_codes = RC_MAP_TEVII_NEC;
+        s662->rc.core.rc_query = dw2102_rc_query;
+        s662->rc.core.rc_interval = 250;
+
+        tt4600 = kmemdup(&su3000_properties,
+                       sizeof(struct dvb_usb_device_properties), GFP_KERNEL);
+        if (!tt4600) {
+                kfree(s421);
+                kfree(p1100);
+                kfree(s660);
+                kfree(p7500);
+                kfree(s662);
+                return -ENOMEM;
+        }
+
+        tt4600->num_device_descs = 1;
+        tt4600->devices[0] = d4600;
+        tt4600->rc.core.rc_codes = RC_MAP_TT_4600;
+        tt4600->rc.core.rc_query = dw2102_rc_query;
+        tt4600->rc.core.rc_interval = 250;
+	tt4600->adapter->fe[0].frontend_attach = su3000_frontend_attach;
+
 	if (0 == dvb_usb_device_init(intf, &dw2102_properties,
 			THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &dw2104_properties,
@@ -2123,6 +2261,10 @@
 			THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, s421,
 			THIS_MODULE, NULL, adapter_nr) ||
+            0 == dvb_usb_device_init(intf, s662,
+                        THIS_MODULE, NULL, adapter_nr) ||
+            0 == dvb_usb_device_init(intf, tt4600,
+                        THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &su3000_properties,
 			 THIS_MODULE, NULL, adapter_nr) ||
 	    0 == dvb_usb_device_init(intf, &t220_properties,
@@ -2144,7 +2286,10 @@
 MODULE_AUTHOR("Igor M. Liplianin (c) liplianin@me.by");
 MODULE_DESCRIPTION("Driver for DVBWorld DVB-S 2101, 2102, DVB-S2 2104,"
 			" DVB-C 3101 USB2.0,"
-			" TeVii S600, S630, S650, S660, S480, S421, S632"
+			" TeVii S600, S630, S650, S660, S480, S421, S632, S662, S482"
+			" Technotrend S2-4600,"
+			" Terratec Cinergy S2 USB BOX,"
+			" Terratec Cinergy S2 PCIe Dual,"
 			" Prof 1100, 7500 USB2.0,"
 			" Geniatech SU3000, T220 devices");
 MODULE_VERSION("0.1");
diff -Naur a/drivers/media/usb/dvb-usb/Kconfig b/drivers/media/usb/dvb-usb/Kconfig
--- a/drivers/media/usb/dvb-usb/Kconfig	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/media/usb/dvb-usb/Kconfig	2014-03-31 21:20:56.000000000 -0700
@@ -272,6 +272,8 @@
 	select DVB_ZL10039 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_DS3000 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_TS2020 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_DS3103 if MEDIA_SUBDRV_AUTOSELECT
+	select DVB_TS2022 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STB6100 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV6110 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0900 if MEDIA_SUBDRV_AUTOSELECT
diff -Naur a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
--- a/drivers/mmc/core/sd.c	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/mmc/core/sd.c	2014-03-31 21:20:56.000000000 -0700
@@ -366,6 +366,15 @@
 		return -ENOMEM;
 	}
 
+	/*
+	 * Some SDHC cards, notably those with a Sandisk SD controller
+	 * (also found in Kingston products) need a bit of slack
+	 * before successfully handling the SWITCH command.  So far,
+	 * cards identifying themselves as "SD04G" and "SD08G" are
+	 * affected
+	 */
+	udelay(100);
+
 	err = mmc_sd_switch(card, 1, 0, 1, status);
 	if (err)
 		goto out;
diff -Naur a/drivers/net/Kconfig b/drivers/net/Kconfig
--- a/drivers/net/Kconfig	2014-03-30 20:40:15.000000000 -0700
+++ b/drivers/net/Kconfig	2014-03-31 21:20:56.000000000 -0700
@@ -26,6 +26,7 @@
 if NETDEVICES
 
 config MII
+	default y
 	tristate
 
 config NET_CORE
diff -Naur a/include/linux/ide.h b/include/linux/ide.h
--- a/include/linux/ide.h	2014-03-30 20:40:15.000000000 -0700
+++ b/include/linux/ide.h	2014-04-19 00:20:56.000000000 -0700
@@ -1516,7 +1516,10 @@
 
 static inline void ide_dump_identify(u8 *id)
 {
-	print_hex_dump(KERN_INFO, "", DUMP_PREFIX_NONE, 16, 2, id, 512, 0);
+
+	print_hex_dump(KERN_DEBUG, "", DUMP_PREFIX_NONE, 16, 2, id, 512, 0);
+
+
 }
 
 static inline int hwif_to_node(ide_hwif_t *hwif)
diff -Naur a/include/linux/leds.h b/include/linux/leds.h
--- a/include/linux/leds.h	2014-03-30 20:40:15.000000000 -0700
+++ b/include/linux/leds.h	2014-03-31 21:20:57.000000000 -0700
@@ -1,6 +1,7 @@
 /*
  * Driver model for leds and led triggers
  *
+ * Copyright 2013 bodhi
  * Copyright (C) 2005 John Lenz <lenz@cs.wisc.edu>
  * Copyright (C) 2005 Richard Purdie <rpurdie@openedhand.com>
  *
@@ -213,9 +214,9 @@
 
 /* Trigger specific functions */
 #ifdef CONFIG_LEDS_TRIGGER_IDE_DISK
-extern void ledtrig_ide_activity(void);
+extern void ledtrig_ide_activity(int portno);
 #else
-static inline void ledtrig_ide_activity(void) {}
+static inline void ledtrig_ide_activity(int portno) {}
 #endif
 
 #if defined(CONFIG_LEDS_TRIGGER_CAMERA) || defined(CONFIG_LEDS_TRIGGER_CAMERA_MODULE)
diff -Naur a/include/linux/nsa3xx-hwmon.h b/include/linux/nsa3xx-hwmon.h
--- a/include/linux/nsa3xx-hwmon.h	1969-12-31 16:00:00.000000000 -0800
+++ b/include/linux/nsa3xx-hwmon.h	2014-03-31 21:20:57.000000000 -0700
@@ -0,0 +1,21 @@
+/*
+ * include/linux/nsa3xx.hwmon.h
+ *
+ * Platform data structure for ZyXEL NSA3xx hwmon driver
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __LINUX_NSA3XX_HWMON_H
+#define __LINUX_NSA3XX_HWMON_H
+
+struct nsa3xx_hwmon_platform_data {
+	/* GPIO pins */
+	unsigned act_pin;
+	unsigned clk_pin;
+	unsigned data_pin;
+};
+
+#endif /* __LINUX_NSA3XX_HWMON_H */
diff -Naur a/include/media/rc-map.h b/include/media/rc-map.h
--- a/include/media/rc-map.h	2014-03-30 20:40:15.000000000 -0700
+++ b/include/media/rc-map.h	2014-04-19 00:27:19.000000000 -0700
@@ -187,6 +187,7 @@
 #define RC_MAP_TOTAL_MEDIA_IN_HAND_02    "rc-total-media-in-hand-02"
 #define RC_MAP_TREKSTOR                  "rc-trekstor"
 #define RC_MAP_TT_1500                   "rc-tt-1500"
+#define RC_MAP_TT_4600                   "rc-tt-4600"
 #define RC_MAP_TWINHAN_VP1027_DVBS       "rc-twinhan1027"
 #define RC_MAP_VIDEOMATE_K100            "rc-videomate-k100"
 #define RC_MAP_VIDEOMATE_S350            "rc-videomate-s350"
